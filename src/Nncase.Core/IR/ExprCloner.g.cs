//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Reactive;

namespace Nncase.IR;

public partial class ExprCloner<TContext>
{
    /// <inheritdoc />
    protected override Expr VisitLeafCall(Call expr, TContext context)
    {
        return expr.With(
            target: Clone(expr.Target, context),
            arguments: CloneArray(expr.Arguments, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafFunction(Function expr, TContext context)
    {
        if (!CanVisitFunctionBody(expr))
        {
            return expr;
        }

        return expr.With(
            parameters: CloneArray(expr.Parameters, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafFusion(Fusion expr, TContext context)
    {
        if (!CanVisitFunctionBody(expr))
        {
            return expr;
        }

        return expr.With(
            parameters: CloneArray(expr.Parameters, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafIf(If expr, TContext context)
    {
        return expr.With(
            condition: Clone(expr.Condition, context),
            then: Clone(expr.Then, context),
            @else: Clone(expr.Else, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafMarker(Marker expr, TContext context)
    {
        return expr.With(
            target: Clone(expr.Target, context),
            attribute: Clone(expr.Attribute, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafNone(None expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafOp(Op expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafPrimFunctionWrapper(PrimFunctionWrapper expr, TContext context)
    {
        if (!CanVisitFunctionBody(expr))
        {
            return expr;
        }

        return expr.With(
            target: Clone(expr.Target, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafTensorConst(TensorConst expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafTuple(IR.Tuple expr, TContext context)
    {
        return expr.With(
            fields: CloneArray(expr.Fields, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafTupleConst(TupleConst expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafMemSpan(TIR.MemSpan expr, TContext context)
    {
        return expr.With(
            start: Clone(expr.Start, context),
            size: Clone(expr.Size, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafVar(Var expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafBlock(TIR.Block expr, TContext context)
    {
        return expr.With(
            body: Clone(expr.Body, context),
            initBody: Clone(expr.InitBody, context),
            iterVars: CloneArray(expr.IterVars, context),
            reads: CloneArray(expr.Reads, context),
            writes: CloneArray(expr.Writes, context),
            allocBuffers: CloneArray(expr.AllocBuffers, context),
            predicate: Clone(expr.Predicate, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafBuffer(TIR.Buffer expr, TContext context)
    {
        return expr.With(
            memSpan: Clone(expr.MemSpan, context),
            dimensions: CloneArray(expr.Dimensions, context),
            strides: CloneArray(expr.Strides, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafBufferRegion(TIR.BufferRegion expr, TContext context)
    {
        return expr.With(
            buffer: Clone(expr.Buffer, context),
            region: CloneArray(expr.Region, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafFor(TIR.For expr, TContext context)
    {
        return expr.With(
            loopVar: Clone(expr.LoopVar, context),
            domain: Clone(expr.Domain, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafIfThenElse(TIR.IfThenElse expr, TContext context)
    {
        return expr.With(
            condition: Clone(expr.Condition, context),
            then: Clone(expr.Then, context),
            @else: Clone(expr.Else, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafLet(TIR.Let expr, TContext context)
    {
        return expr.With(
            var: Clone(expr.Var, context),
            expression: Clone(expr.Expression, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafPrimFunction(TIR.PrimFunction expr, TContext context)
    {
        if (!CanVisitFunctionBody(expr))
        {
            return expr;
        }

        return expr.With(
            parameters: CloneArray(expr.Parameters, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafSequential(TIR.Sequential expr, TContext context)
    {
        return expr.With(
            fields: CloneArray(expr.Fields, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafRange(TIR.Range expr, TContext context)
    {
        return expr.With(
            start: Clone(expr.Start, context),
            stop: Clone(expr.Stop, context),
            step: Clone(expr.Step, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafIterVar(TIR.IterVar expr, TContext context)
    {
        return expr.With(
            value: Clone(expr.Value, context),
            dom: Clone(expr.Dom, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineDim(Affine.AffineDim expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineExtent(Affine.AffineExtent expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineSymbol(Affine.AffineSymbol expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineConstant(Affine.AffineConstant expr, TContext context)
    {
        return expr.With(
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineAddBinary(Affine.AffineAddBinary expr, TContext context)
    {
        return expr.With(
            lhs: Clone(expr.Lhs, context),
            rhs: Clone(expr.Rhs, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineMulBinary(Affine.AffineMulBinary expr, TContext context)
    {
        return expr.With(
            lhs: Clone(expr.Lhs, context),
            rhs: Clone(expr.Rhs, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineDivBinary(Affine.AffineDivBinary expr, TContext context)
    {
        return expr.With(
            lhs: Clone(expr.Lhs, context),
            rhs: Clone(expr.Rhs, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineDomain(Affine.AffineDomain expr, TContext context)
    {
        return expr.With(
            offset: Clone(expr.Offset, context),
            extent: Clone(expr.Extent, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineRange(Affine.AffineRange expr, TContext context)
    {
        return expr.With(
            offset: Clone(expr.Offset, context),
            extent: Clone(expr.Extent, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafAffineMap(Affine.AffineMap expr, TContext context)
    {
        return expr.With(
            domains: CloneArray(expr.Domains, context),
            symbols: CloneArray(expr.Symbols, context),
            results: CloneArray(expr.Results, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafGrid(Affine.Grid expr, TContext context)
    {
        return expr.With(
            bodyParameters: CloneArray(expr.BodyParameters, context),
            accessMaps: CloneArray(expr.AccessMaps, context),
            buffers: CloneArray(expr.Buffers, context),
            reads: CloneArray(expr.Reads, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafLoad(Affine.Load expr, TContext context)
    {
        return expr.With(
            source: Clone(expr.Source, context),
            region: Clone(expr.Region, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafFor(Affine.For expr, TContext context)
    {
        return expr.With(
            domain: Clone(expr.Domain, context),
            body: Clone(expr.Body, context)
        );
    }

    /// <inheritdoc />
    protected override Expr VisitLeafBufferOf(Buffers.BufferOf expr, TContext context)
    {
        return expr.With(
            input: Clone(expr.Input, context)
        );
    }

}
