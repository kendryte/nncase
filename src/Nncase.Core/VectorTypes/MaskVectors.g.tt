<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using CommunityToolkit.HighPerformance;
using DryIoc;

namespace Nncase;

// NOTE fixed array not suppot generic

<#
var elemTypeAndBitsValues = new[] { ("byte", 8), ("ushort", 16), ("uint", 32), ("ulong", 64) };
var bitsValues = new[] { 128, 256, 512, 1024 };
var styleValues = new[] { "Fat", "Slim" };
#>
public partial record MaskVectorType
{
    public override Type CLRType => (Style, ElementBits, Lanes) switch
    {
<#
foreach (var (elemType, elemBits) in elemTypeAndBitsValues)
{
    foreach (var bits in bitsValues)
    {
        var lanes = bits / elemBits;
        foreach (var style in styleValues)
        { 
            var typeName = $"MaskVector{lanes}B{elemBits}{style}";#>
        (MaskVectorStyle.<#=style#>, <#=elemBits#>, <#=lanes#>) => typeof(<#=typeName#>),
<#}}}#>
        _ => throw new NotSupportedException(),
    };
}

internal partial class CoreModule
{
    private static partial void RegisterMaskTypes(IRegistrator registrator)
    {
<#
foreach (var (elemType, elemBits) in elemTypeAndBitsValues)
{
    foreach (var bits in bitsValues)
    {
        var lanes = bits / elemBits;
        foreach (var style in styleValues)
        { 
            var typeName = $"MaskVector{lanes}B{elemBits}{style}";#>
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.<#=style#>, <#=elemBits#>, <#=lanes#>));
<#}}}#>
    }
}

<#
foreach (var (elemType, elemBits) in elemTypeAndBitsValues)
{
    foreach (var bits in bitsValues)
    {
        var lanes = bits / elemBits;
        foreach (var style in styleValues)
        {
var typeName = $"MaskVector{lanes}B{elemBits}{style}";
#>
[StructLayout(LayoutKind.Sequential)]
public unsafe struct <#=typeName#> : IMaskVector, IEquatable<<#=typeName#>>
{
<# if (style == "Fat") { #>
    private const <#=elemType#> trueValue = unchecked((<#=elemType#>)-1);
<# } #>

<# if (style == "Fat") { #>
<# foreach (var i in Enumerable.Range(0, lanes)) { #>
    private <#=elemType#> _item_0_<#=i#>;
<#}#>
<# } else { #>
<# foreach (var i in Enumerable.Range(0, bits / 64)) { #>
    private ulong _item_0_<#=i#>;
<#}#>
<# } #>

    public static int Count => <#=lanes#>;

    public static <#=typeName#> Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        <#=typeName#> vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

<# if (style == "Fat") { #>
    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (<#=elemType#>)0;
    }
<# } else { #>
    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }
<# } #>

    public bool Equals(<#=typeName#> other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is <#=typeName#> other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

<#foreach (var op in new string[] { }) {#>
    public static <#=typeName#> operator <#=op#>(<#=typeName#> left, <#=typeName#> right) 
    {
        <#=typeName#> res = default;
        var lhs = left.AsSpan();
        var rhs = right.AsSpan();
        var span = res.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            span[i] = lhs[i] <#=op#> rhs[i];
        }
        return res;
    }

<#}#>
    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

<# if (style == "Fat") { #>
    public Span<<#=elemType#>> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), <#=lanes#>);
<# } else { #>
    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), <#=(bits / 64)#>);
<# } #>
}

<#}}}#>