//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using CommunityToolkit.HighPerformance;
using DryIoc;

namespace Nncase;

// NOTE fixed array not suppot generic

public partial record MaskVectorType
{
    public override Type CLRType => (Style, ElementBits, Lanes) switch
    {
        (MaskVectorStyle.Fat, 8, 16) => typeof(MaskVector16B8Fat),
        (MaskVectorStyle.Slim, 8, 16) => typeof(MaskVector16B8Slim),
        (MaskVectorStyle.Fat, 8, 32) => typeof(MaskVector32B8Fat),
        (MaskVectorStyle.Slim, 8, 32) => typeof(MaskVector32B8Slim),
        (MaskVectorStyle.Fat, 8, 64) => typeof(MaskVector64B8Fat),
        (MaskVectorStyle.Slim, 8, 64) => typeof(MaskVector64B8Slim),
        (MaskVectorStyle.Fat, 8, 128) => typeof(MaskVector128B8Fat),
        (MaskVectorStyle.Slim, 8, 128) => typeof(MaskVector128B8Slim),
        (MaskVectorStyle.Fat, 16, 8) => typeof(MaskVector8B16Fat),
        (MaskVectorStyle.Slim, 16, 8) => typeof(MaskVector8B16Slim),
        (MaskVectorStyle.Fat, 16, 16) => typeof(MaskVector16B16Fat),
        (MaskVectorStyle.Slim, 16, 16) => typeof(MaskVector16B16Slim),
        (MaskVectorStyle.Fat, 16, 32) => typeof(MaskVector32B16Fat),
        (MaskVectorStyle.Slim, 16, 32) => typeof(MaskVector32B16Slim),
        (MaskVectorStyle.Fat, 16, 64) => typeof(MaskVector64B16Fat),
        (MaskVectorStyle.Slim, 16, 64) => typeof(MaskVector64B16Slim),
        (MaskVectorStyle.Fat, 32, 4) => typeof(MaskVector4B32Fat),
        (MaskVectorStyle.Slim, 32, 4) => typeof(MaskVector4B32Slim),
        (MaskVectorStyle.Fat, 32, 8) => typeof(MaskVector8B32Fat),
        (MaskVectorStyle.Slim, 32, 8) => typeof(MaskVector8B32Slim),
        (MaskVectorStyle.Fat, 32, 16) => typeof(MaskVector16B32Fat),
        (MaskVectorStyle.Slim, 32, 16) => typeof(MaskVector16B32Slim),
        (MaskVectorStyle.Fat, 32, 32) => typeof(MaskVector32B32Fat),
        (MaskVectorStyle.Slim, 32, 32) => typeof(MaskVector32B32Slim),
        (MaskVectorStyle.Fat, 64, 2) => typeof(MaskVector2B64Fat),
        (MaskVectorStyle.Slim, 64, 2) => typeof(MaskVector2B64Slim),
        (MaskVectorStyle.Fat, 64, 4) => typeof(MaskVector4B64Fat),
        (MaskVectorStyle.Slim, 64, 4) => typeof(MaskVector4B64Slim),
        (MaskVectorStyle.Fat, 64, 8) => typeof(MaskVector8B64Fat),
        (MaskVectorStyle.Slim, 64, 8) => typeof(MaskVector8B64Slim),
        (MaskVectorStyle.Fat, 64, 16) => typeof(MaskVector16B64Fat),
        (MaskVectorStyle.Slim, 64, 16) => typeof(MaskVector16B64Slim),
        _ => throw new NotSupportedException(),
    };
}

internal partial class CoreModule
{
    private static partial void RegisterMaskTypes(IRegistrator registrator)
    {
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 8, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 8, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 8, 32));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 8, 32));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 8, 64));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 8, 64));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 8, 128));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 8, 128));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 16, 8));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 16, 8));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 16, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 16, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 16, 32));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 16, 32));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 16, 64));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 16, 64));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 32, 4));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 32, 4));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 32, 8));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 32, 8));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 32, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 32, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 32, 32));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 32, 32));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 64, 2));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 64, 2));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 64, 4));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 64, 4));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 64, 8));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 64, 8));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Fat, 64, 16));
        registrator.RegisterInstance(new MaskVectorType(MaskVectorStyle.Slim, 64, 16));
    }
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B8Fat : IMaskVector, IEquatable<MaskVector16B8Fat>
{
    private const byte trueValue = unchecked((byte)-1);

    private byte _item_0_0;
    private byte _item_0_1;
    private byte _item_0_2;
    private byte _item_0_3;
    private byte _item_0_4;
    private byte _item_0_5;
    private byte _item_0_6;
    private byte _item_0_7;
    private byte _item_0_8;
    private byte _item_0_9;
    private byte _item_0_10;
    private byte _item_0_11;
    private byte _item_0_12;
    private byte _item_0_13;
    private byte _item_0_14;
    private byte _item_0_15;

    public static int Count => 16;

    public static MaskVector16B8Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B8Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (byte)0;
    }

    public bool Equals(MaskVector16B8Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B8Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<byte> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B8Slim : IMaskVector, IEquatable<MaskVector16B8Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;

    public static int Count => 16;

    public static MaskVector16B8Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B8Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector16B8Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B8Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 2);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector32B8Fat : IMaskVector, IEquatable<MaskVector32B8Fat>
{
    private const byte trueValue = unchecked((byte)-1);

    private byte _item_0_0;
    private byte _item_0_1;
    private byte _item_0_2;
    private byte _item_0_3;
    private byte _item_0_4;
    private byte _item_0_5;
    private byte _item_0_6;
    private byte _item_0_7;
    private byte _item_0_8;
    private byte _item_0_9;
    private byte _item_0_10;
    private byte _item_0_11;
    private byte _item_0_12;
    private byte _item_0_13;
    private byte _item_0_14;
    private byte _item_0_15;
    private byte _item_0_16;
    private byte _item_0_17;
    private byte _item_0_18;
    private byte _item_0_19;
    private byte _item_0_20;
    private byte _item_0_21;
    private byte _item_0_22;
    private byte _item_0_23;
    private byte _item_0_24;
    private byte _item_0_25;
    private byte _item_0_26;
    private byte _item_0_27;
    private byte _item_0_28;
    private byte _item_0_29;
    private byte _item_0_30;
    private byte _item_0_31;

    public static int Count => 32;

    public static MaskVector32B8Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector32B8Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (byte)0;
    }

    public bool Equals(MaskVector32B8Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector32B8Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<byte> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 32);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector32B8Slim : IMaskVector, IEquatable<MaskVector32B8Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;

    public static int Count => 32;

    public static MaskVector32B8Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector32B8Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector32B8Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector32B8Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 4);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector64B8Fat : IMaskVector, IEquatable<MaskVector64B8Fat>
{
    private const byte trueValue = unchecked((byte)-1);

    private byte _item_0_0;
    private byte _item_0_1;
    private byte _item_0_2;
    private byte _item_0_3;
    private byte _item_0_4;
    private byte _item_0_5;
    private byte _item_0_6;
    private byte _item_0_7;
    private byte _item_0_8;
    private byte _item_0_9;
    private byte _item_0_10;
    private byte _item_0_11;
    private byte _item_0_12;
    private byte _item_0_13;
    private byte _item_0_14;
    private byte _item_0_15;
    private byte _item_0_16;
    private byte _item_0_17;
    private byte _item_0_18;
    private byte _item_0_19;
    private byte _item_0_20;
    private byte _item_0_21;
    private byte _item_0_22;
    private byte _item_0_23;
    private byte _item_0_24;
    private byte _item_0_25;
    private byte _item_0_26;
    private byte _item_0_27;
    private byte _item_0_28;
    private byte _item_0_29;
    private byte _item_0_30;
    private byte _item_0_31;
    private byte _item_0_32;
    private byte _item_0_33;
    private byte _item_0_34;
    private byte _item_0_35;
    private byte _item_0_36;
    private byte _item_0_37;
    private byte _item_0_38;
    private byte _item_0_39;
    private byte _item_0_40;
    private byte _item_0_41;
    private byte _item_0_42;
    private byte _item_0_43;
    private byte _item_0_44;
    private byte _item_0_45;
    private byte _item_0_46;
    private byte _item_0_47;
    private byte _item_0_48;
    private byte _item_0_49;
    private byte _item_0_50;
    private byte _item_0_51;
    private byte _item_0_52;
    private byte _item_0_53;
    private byte _item_0_54;
    private byte _item_0_55;
    private byte _item_0_56;
    private byte _item_0_57;
    private byte _item_0_58;
    private byte _item_0_59;
    private byte _item_0_60;
    private byte _item_0_61;
    private byte _item_0_62;
    private byte _item_0_63;

    public static int Count => 64;

    public static MaskVector64B8Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector64B8Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (byte)0;
    }

    public bool Equals(MaskVector64B8Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector64B8Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<byte> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 64);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector64B8Slim : IMaskVector, IEquatable<MaskVector64B8Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;

    public static int Count => 64;

    public static MaskVector64B8Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector64B8Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector64B8Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector64B8Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector128B8Fat : IMaskVector, IEquatable<MaskVector128B8Fat>
{
    private const byte trueValue = unchecked((byte)-1);

    private byte _item_0_0;
    private byte _item_0_1;
    private byte _item_0_2;
    private byte _item_0_3;
    private byte _item_0_4;
    private byte _item_0_5;
    private byte _item_0_6;
    private byte _item_0_7;
    private byte _item_0_8;
    private byte _item_0_9;
    private byte _item_0_10;
    private byte _item_0_11;
    private byte _item_0_12;
    private byte _item_0_13;
    private byte _item_0_14;
    private byte _item_0_15;
    private byte _item_0_16;
    private byte _item_0_17;
    private byte _item_0_18;
    private byte _item_0_19;
    private byte _item_0_20;
    private byte _item_0_21;
    private byte _item_0_22;
    private byte _item_0_23;
    private byte _item_0_24;
    private byte _item_0_25;
    private byte _item_0_26;
    private byte _item_0_27;
    private byte _item_0_28;
    private byte _item_0_29;
    private byte _item_0_30;
    private byte _item_0_31;
    private byte _item_0_32;
    private byte _item_0_33;
    private byte _item_0_34;
    private byte _item_0_35;
    private byte _item_0_36;
    private byte _item_0_37;
    private byte _item_0_38;
    private byte _item_0_39;
    private byte _item_0_40;
    private byte _item_0_41;
    private byte _item_0_42;
    private byte _item_0_43;
    private byte _item_0_44;
    private byte _item_0_45;
    private byte _item_0_46;
    private byte _item_0_47;
    private byte _item_0_48;
    private byte _item_0_49;
    private byte _item_0_50;
    private byte _item_0_51;
    private byte _item_0_52;
    private byte _item_0_53;
    private byte _item_0_54;
    private byte _item_0_55;
    private byte _item_0_56;
    private byte _item_0_57;
    private byte _item_0_58;
    private byte _item_0_59;
    private byte _item_0_60;
    private byte _item_0_61;
    private byte _item_0_62;
    private byte _item_0_63;
    private byte _item_0_64;
    private byte _item_0_65;
    private byte _item_0_66;
    private byte _item_0_67;
    private byte _item_0_68;
    private byte _item_0_69;
    private byte _item_0_70;
    private byte _item_0_71;
    private byte _item_0_72;
    private byte _item_0_73;
    private byte _item_0_74;
    private byte _item_0_75;
    private byte _item_0_76;
    private byte _item_0_77;
    private byte _item_0_78;
    private byte _item_0_79;
    private byte _item_0_80;
    private byte _item_0_81;
    private byte _item_0_82;
    private byte _item_0_83;
    private byte _item_0_84;
    private byte _item_0_85;
    private byte _item_0_86;
    private byte _item_0_87;
    private byte _item_0_88;
    private byte _item_0_89;
    private byte _item_0_90;
    private byte _item_0_91;
    private byte _item_0_92;
    private byte _item_0_93;
    private byte _item_0_94;
    private byte _item_0_95;
    private byte _item_0_96;
    private byte _item_0_97;
    private byte _item_0_98;
    private byte _item_0_99;
    private byte _item_0_100;
    private byte _item_0_101;
    private byte _item_0_102;
    private byte _item_0_103;
    private byte _item_0_104;
    private byte _item_0_105;
    private byte _item_0_106;
    private byte _item_0_107;
    private byte _item_0_108;
    private byte _item_0_109;
    private byte _item_0_110;
    private byte _item_0_111;
    private byte _item_0_112;
    private byte _item_0_113;
    private byte _item_0_114;
    private byte _item_0_115;
    private byte _item_0_116;
    private byte _item_0_117;
    private byte _item_0_118;
    private byte _item_0_119;
    private byte _item_0_120;
    private byte _item_0_121;
    private byte _item_0_122;
    private byte _item_0_123;
    private byte _item_0_124;
    private byte _item_0_125;
    private byte _item_0_126;
    private byte _item_0_127;

    public static int Count => 128;

    public static MaskVector128B8Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector128B8Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (byte)0;
    }

    public bool Equals(MaskVector128B8Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector128B8Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<byte> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 128);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector128B8Slim : IMaskVector, IEquatable<MaskVector128B8Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;
    private ulong _item_0_8;
    private ulong _item_0_9;
    private ulong _item_0_10;
    private ulong _item_0_11;
    private ulong _item_0_12;
    private ulong _item_0_13;
    private ulong _item_0_14;
    private ulong _item_0_15;

    public static int Count => 128;

    public static MaskVector128B8Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector128B8Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector128B8Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector128B8Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector8B16Fat : IMaskVector, IEquatable<MaskVector8B16Fat>
{
    private const ushort trueValue = unchecked((ushort)-1);

    private ushort _item_0_0;
    private ushort _item_0_1;
    private ushort _item_0_2;
    private ushort _item_0_3;
    private ushort _item_0_4;
    private ushort _item_0_5;
    private ushort _item_0_6;
    private ushort _item_0_7;

    public static int Count => 8;

    public static MaskVector8B16Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector8B16Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ushort)0;
    }

    public bool Equals(MaskVector8B16Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector8B16Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ushort> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector8B16Slim : IMaskVector, IEquatable<MaskVector8B16Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;

    public static int Count => 8;

    public static MaskVector8B16Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector8B16Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector8B16Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector8B16Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 2);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B16Fat : IMaskVector, IEquatable<MaskVector16B16Fat>
{
    private const ushort trueValue = unchecked((ushort)-1);

    private ushort _item_0_0;
    private ushort _item_0_1;
    private ushort _item_0_2;
    private ushort _item_0_3;
    private ushort _item_0_4;
    private ushort _item_0_5;
    private ushort _item_0_6;
    private ushort _item_0_7;
    private ushort _item_0_8;
    private ushort _item_0_9;
    private ushort _item_0_10;
    private ushort _item_0_11;
    private ushort _item_0_12;
    private ushort _item_0_13;
    private ushort _item_0_14;
    private ushort _item_0_15;

    public static int Count => 16;

    public static MaskVector16B16Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B16Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ushort)0;
    }

    public bool Equals(MaskVector16B16Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B16Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ushort> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B16Slim : IMaskVector, IEquatable<MaskVector16B16Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;

    public static int Count => 16;

    public static MaskVector16B16Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B16Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector16B16Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B16Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 4);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector32B16Fat : IMaskVector, IEquatable<MaskVector32B16Fat>
{
    private const ushort trueValue = unchecked((ushort)-1);

    private ushort _item_0_0;
    private ushort _item_0_1;
    private ushort _item_0_2;
    private ushort _item_0_3;
    private ushort _item_0_4;
    private ushort _item_0_5;
    private ushort _item_0_6;
    private ushort _item_0_7;
    private ushort _item_0_8;
    private ushort _item_0_9;
    private ushort _item_0_10;
    private ushort _item_0_11;
    private ushort _item_0_12;
    private ushort _item_0_13;
    private ushort _item_0_14;
    private ushort _item_0_15;
    private ushort _item_0_16;
    private ushort _item_0_17;
    private ushort _item_0_18;
    private ushort _item_0_19;
    private ushort _item_0_20;
    private ushort _item_0_21;
    private ushort _item_0_22;
    private ushort _item_0_23;
    private ushort _item_0_24;
    private ushort _item_0_25;
    private ushort _item_0_26;
    private ushort _item_0_27;
    private ushort _item_0_28;
    private ushort _item_0_29;
    private ushort _item_0_30;
    private ushort _item_0_31;

    public static int Count => 32;

    public static MaskVector32B16Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector32B16Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ushort)0;
    }

    public bool Equals(MaskVector32B16Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector32B16Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ushort> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 32);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector32B16Slim : IMaskVector, IEquatable<MaskVector32B16Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;

    public static int Count => 32;

    public static MaskVector32B16Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector32B16Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector32B16Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector32B16Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector64B16Fat : IMaskVector, IEquatable<MaskVector64B16Fat>
{
    private const ushort trueValue = unchecked((ushort)-1);

    private ushort _item_0_0;
    private ushort _item_0_1;
    private ushort _item_0_2;
    private ushort _item_0_3;
    private ushort _item_0_4;
    private ushort _item_0_5;
    private ushort _item_0_6;
    private ushort _item_0_7;
    private ushort _item_0_8;
    private ushort _item_0_9;
    private ushort _item_0_10;
    private ushort _item_0_11;
    private ushort _item_0_12;
    private ushort _item_0_13;
    private ushort _item_0_14;
    private ushort _item_0_15;
    private ushort _item_0_16;
    private ushort _item_0_17;
    private ushort _item_0_18;
    private ushort _item_0_19;
    private ushort _item_0_20;
    private ushort _item_0_21;
    private ushort _item_0_22;
    private ushort _item_0_23;
    private ushort _item_0_24;
    private ushort _item_0_25;
    private ushort _item_0_26;
    private ushort _item_0_27;
    private ushort _item_0_28;
    private ushort _item_0_29;
    private ushort _item_0_30;
    private ushort _item_0_31;
    private ushort _item_0_32;
    private ushort _item_0_33;
    private ushort _item_0_34;
    private ushort _item_0_35;
    private ushort _item_0_36;
    private ushort _item_0_37;
    private ushort _item_0_38;
    private ushort _item_0_39;
    private ushort _item_0_40;
    private ushort _item_0_41;
    private ushort _item_0_42;
    private ushort _item_0_43;
    private ushort _item_0_44;
    private ushort _item_0_45;
    private ushort _item_0_46;
    private ushort _item_0_47;
    private ushort _item_0_48;
    private ushort _item_0_49;
    private ushort _item_0_50;
    private ushort _item_0_51;
    private ushort _item_0_52;
    private ushort _item_0_53;
    private ushort _item_0_54;
    private ushort _item_0_55;
    private ushort _item_0_56;
    private ushort _item_0_57;
    private ushort _item_0_58;
    private ushort _item_0_59;
    private ushort _item_0_60;
    private ushort _item_0_61;
    private ushort _item_0_62;
    private ushort _item_0_63;

    public static int Count => 64;

    public static MaskVector64B16Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector64B16Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ushort)0;
    }

    public bool Equals(MaskVector64B16Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector64B16Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ushort> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 64);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector64B16Slim : IMaskVector, IEquatable<MaskVector64B16Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;
    private ulong _item_0_8;
    private ulong _item_0_9;
    private ulong _item_0_10;
    private ulong _item_0_11;
    private ulong _item_0_12;
    private ulong _item_0_13;
    private ulong _item_0_14;
    private ulong _item_0_15;

    public static int Count => 64;

    public static MaskVector64B16Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector64B16Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector64B16Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector64B16Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector4B32Fat : IMaskVector, IEquatable<MaskVector4B32Fat>
{
    private const uint trueValue = unchecked((uint)-1);

    private uint _item_0_0;
    private uint _item_0_1;
    private uint _item_0_2;
    private uint _item_0_3;

    public static int Count => 4;

    public static MaskVector4B32Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector4B32Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (uint)0;
    }

    public bool Equals(MaskVector4B32Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector4B32Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<uint> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 4);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector4B32Slim : IMaskVector, IEquatable<MaskVector4B32Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;

    public static int Count => 4;

    public static MaskVector4B32Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector4B32Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector4B32Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector4B32Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 2);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector8B32Fat : IMaskVector, IEquatable<MaskVector8B32Fat>
{
    private const uint trueValue = unchecked((uint)-1);

    private uint _item_0_0;
    private uint _item_0_1;
    private uint _item_0_2;
    private uint _item_0_3;
    private uint _item_0_4;
    private uint _item_0_5;
    private uint _item_0_6;
    private uint _item_0_7;

    public static int Count => 8;

    public static MaskVector8B32Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector8B32Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (uint)0;
    }

    public bool Equals(MaskVector8B32Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector8B32Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<uint> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector8B32Slim : IMaskVector, IEquatable<MaskVector8B32Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;

    public static int Count => 8;

    public static MaskVector8B32Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector8B32Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector8B32Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector8B32Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 4);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B32Fat : IMaskVector, IEquatable<MaskVector16B32Fat>
{
    private const uint trueValue = unchecked((uint)-1);

    private uint _item_0_0;
    private uint _item_0_1;
    private uint _item_0_2;
    private uint _item_0_3;
    private uint _item_0_4;
    private uint _item_0_5;
    private uint _item_0_6;
    private uint _item_0_7;
    private uint _item_0_8;
    private uint _item_0_9;
    private uint _item_0_10;
    private uint _item_0_11;
    private uint _item_0_12;
    private uint _item_0_13;
    private uint _item_0_14;
    private uint _item_0_15;

    public static int Count => 16;

    public static MaskVector16B32Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B32Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (uint)0;
    }

    public bool Equals(MaskVector16B32Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B32Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<uint> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B32Slim : IMaskVector, IEquatable<MaskVector16B32Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;

    public static int Count => 16;

    public static MaskVector16B32Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B32Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector16B32Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B32Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector32B32Fat : IMaskVector, IEquatable<MaskVector32B32Fat>
{
    private const uint trueValue = unchecked((uint)-1);

    private uint _item_0_0;
    private uint _item_0_1;
    private uint _item_0_2;
    private uint _item_0_3;
    private uint _item_0_4;
    private uint _item_0_5;
    private uint _item_0_6;
    private uint _item_0_7;
    private uint _item_0_8;
    private uint _item_0_9;
    private uint _item_0_10;
    private uint _item_0_11;
    private uint _item_0_12;
    private uint _item_0_13;
    private uint _item_0_14;
    private uint _item_0_15;
    private uint _item_0_16;
    private uint _item_0_17;
    private uint _item_0_18;
    private uint _item_0_19;
    private uint _item_0_20;
    private uint _item_0_21;
    private uint _item_0_22;
    private uint _item_0_23;
    private uint _item_0_24;
    private uint _item_0_25;
    private uint _item_0_26;
    private uint _item_0_27;
    private uint _item_0_28;
    private uint _item_0_29;
    private uint _item_0_30;
    private uint _item_0_31;

    public static int Count => 32;

    public static MaskVector32B32Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector32B32Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (uint)0;
    }

    public bool Equals(MaskVector32B32Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector32B32Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<uint> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 32);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector32B32Slim : IMaskVector, IEquatable<MaskVector32B32Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;
    private ulong _item_0_8;
    private ulong _item_0_9;
    private ulong _item_0_10;
    private ulong _item_0_11;
    private ulong _item_0_12;
    private ulong _item_0_13;
    private ulong _item_0_14;
    private ulong _item_0_15;

    public static int Count => 32;

    public static MaskVector32B32Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector32B32Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector32B32Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector32B32Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector2B64Fat : IMaskVector, IEquatable<MaskVector2B64Fat>
{
    private const ulong trueValue = unchecked((ulong)-1);

    private ulong _item_0_0;
    private ulong _item_0_1;

    public static int Count => 2;

    public static MaskVector2B64Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector2B64Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ulong)0;
    }

    public bool Equals(MaskVector2B64Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector2B64Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 2);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector2B64Slim : IMaskVector, IEquatable<MaskVector2B64Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;

    public static int Count => 2;

    public static MaskVector2B64Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector2B64Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector2B64Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector2B64Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 2);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector4B64Fat : IMaskVector, IEquatable<MaskVector4B64Fat>
{
    private const ulong trueValue = unchecked((ulong)-1);

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;

    public static int Count => 4;

    public static MaskVector4B64Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector4B64Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ulong)0;
    }

    public bool Equals(MaskVector4B64Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector4B64Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 4);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector4B64Slim : IMaskVector, IEquatable<MaskVector4B64Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;

    public static int Count => 4;

    public static MaskVector4B64Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector4B64Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector4B64Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector4B64Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 4);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector8B64Fat : IMaskVector, IEquatable<MaskVector8B64Fat>
{
    private const ulong trueValue = unchecked((ulong)-1);

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;

    public static int Count => 8;

    public static MaskVector8B64Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector8B64Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ulong)0;
    }

    public bool Equals(MaskVector8B64Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector8B64Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector8B64Slim : IMaskVector, IEquatable<MaskVector8B64Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;

    public static int Count => 8;

    public static MaskVector8B64Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector8B64Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector8B64Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector8B64Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 8);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B64Fat : IMaskVector, IEquatable<MaskVector16B64Fat>
{
    private const ulong trueValue = unchecked((ulong)-1);

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;
    private ulong _item_0_8;
    private ulong _item_0_9;
    private ulong _item_0_10;
    private ulong _item_0_11;
    private ulong _item_0_12;
    private ulong _item_0_13;
    private ulong _item_0_14;
    private ulong _item_0_15;

    public static int Count => 16;

    public static MaskVector16B64Fat Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B64Fat vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => AsRawSpan()[i] != 0;
        set => AsRawSpan()[i] = value ? trueValue : (ulong)0;
    }

    public bool Equals(MaskVector16B64Fat other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B64Fat other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

[StructLayout(LayoutKind.Sequential)]
public unsafe struct MaskVector16B64Slim : IMaskVector, IEquatable<MaskVector16B64Slim>
{

    private ulong _item_0_0;
    private ulong _item_0_1;
    private ulong _item_0_2;
    private ulong _item_0_3;
    private ulong _item_0_4;
    private ulong _item_0_5;
    private ulong _item_0_6;
    private ulong _item_0_7;
    private ulong _item_0_8;
    private ulong _item_0_9;
    private ulong _item_0_10;
    private ulong _item_0_11;
    private ulong _item_0_12;
    private ulong _item_0_13;
    private ulong _item_0_14;
    private ulong _item_0_15;

    public static int Count => 16;

    public static MaskVector16B64Slim Create(bool[] array) 
    {
        if (array.Length != Count)
        {
            throw new ArgumentException(nameof(array), "Array length mismatch.");
        }

        MaskVector16B64Slim vec = default;
        for (int i = 0; i < Count; i++)
        {
            vec[i] = array[i];
        }

        return vec;
    }

    public bool this[int i]
    {
        get => (AsRawSpan()[i / 64] & (1UL << (i % 64))) != 0;
        set
        {
            ref var elem = ref AsRawSpan()[i / 64];
            var mask = ~(1UL << (i % 64));
            elem = (elem & mask) | (value ? (1UL << (i % 64)) : 0);
        }
    }

    public bool Equals(MaskVector16B64Slim other) => AsRawSpan().SequenceEqual(other.AsRawSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is MaskVector16B64Slim other && Equals(other);

    public void CopyFrom(ReadOnlySpan<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            this[i] = values[i];
        }
    }

    public void CopyTo(Span<bool> values)
    {
        if (values.Length != Count)
        {
            throw new ArgumentException(nameof(values), "Array length mismatch.");
        }

        for (int i = 0; i < Count; i++)
        {
            values[i] = this[i];
        }
    }

    public override string ToString()
    {
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Count; i++)
        {
            sb.Append($"{this[i]}");
            if (i < Count - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
    }

    public Span<ulong> AsRawSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), 16);
}

