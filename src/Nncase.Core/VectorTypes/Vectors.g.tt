<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CommunityToolkit.HighPerformance;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;

namespace Nncase;

// NOTE fixed array not suppot generic

<# 
foreach (var (lanesA, lanesB) in new[] { 
  (0, 4), (0, 8), (0, 16), (0, 32), (0, 64), (0, 128),
  (4, 4), (8, 8), (16, 16), (32, 16), (32, 32), (32, 64), (32, 128), (64, 32), (64, 64), (64, 128), (128, 64) })
{  
var typeName = lanesA == 0 ? $"Vector{lanesB.ToString()}<T>" : $"Vector{lanesA.ToString()}x{lanesB.ToString()}<T>";
#>
[StructLayout(LayoutKind.Sequential)]
public unsafe struct <#=typeName#> : INumberBase<<#=typeName#>>
    where T : unmanaged, IEquatable<T>, INumber<T>
{
<# if (lanesA == 0) {#>
<# foreach (var i in Enumerable.Range(0, lanesB)) { #>
    private T _item_0_<#=i#>;
<#}#>
<#} else {#>
<# foreach (var i in Enumerable.Range(0, lanesA)) { 
   foreach (var j in Enumerable.Range(0, lanesB)) {#>
    private T _item_<#=i#>_<#=j#>;
<#}}#>
<#}#>

    public static <#=typeName#> Create(T[<#=(lanesA == 0) ? "" : ","#>] array) 
    {
        <#=typeName#> vec = default;
        var src = array.AsSpan<#= lanesA == 0 ? "" : "2D"#>();
        var dest = vec.AsSpan<#= lanesA == 0 ? "" : "2D"#>();
        src.CopyTo(dest);
        return vec;
    }

<# if (lanesA == 0) {#>
    public T this[int i]
    {
        get => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i);
        set => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i) = value;
    }
<#} else {#>
    public T this[int i, int j]
    {
        get => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i * Width + j);
        set => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i * Width + j) = value;
    }
<#}#>

    public bool Equals(<#=typeName#> other) => AsSpan().SequenceEqual(other.AsSpan());

    public override bool Equals([NotNullWhen(true)] object obj) => obj is <#=typeName#> other && Equals(other);

    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), Count);

<# if (lanesA != 0) {#>

    public Span<T> AsSpan(int i) => MemoryMarshal.CreateSpan(ref Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i * Width), Width);

    public Span2D<T> AsSpan2D() => Span2D<T>.DangerousCreate(ref Unsafe.AsRef(in _item_0_0), Height, Width, 1);

    public int Height => <#=lanesA#>;

    public int Width => <#=lanesB#>;

    public int Count => Height * Width;
<# } else {#>
    public int Count => <#=lanesB#>;
<#}#>

    public static <#=typeName#> One 
    {
        get 
        {
            <#=typeName#> result = default;
            var span = result.AsSpan();
            for (int i = 0; i < span.Length; i++)
            {
                span[i] = T.One;
            }

            return result;
        }
    }

    public static int Radix => T.Radix;

    public static <#=typeName#> Zero 
    {
        get 
        {
            <#=typeName#> result = default;
            var span = result.AsSpan();
            for (int i = 0; i < span.Length; i++)
            {
                span[i] = T.Zero;
            }

            return result;
        }
    }

    public static <#=typeName#> AdditiveIdentity => Zero;

    public static <#=typeName#> MultiplicativeIdentity => One;

<#foreach (var op in new string[] { "+", "-" , "*", "/" }) {#>
    public static <#=typeName#> operator <#=op#>(<#=typeName#> left, <#=typeName#> right) 
    {
        <#=typeName#> res = default;
        var lhs = left.AsSpan();
        var rhs = right.AsSpan();
        var span = res.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            span[i] = lhs[i] <#=op#> rhs[i];
        }
        return res;
    }

<#}#>

    public static <#=typeName#> operator --(<#=typeName#> value) => throw new NotImplementedException();
    public static bool operator ==(<#=typeName#> left, <#=typeName#> right) => throw new NotImplementedException();
    public static bool operator !=(<#=typeName#> left, <#=typeName#> right) => throw new NotImplementedException();
    public static <#=typeName#> operator ++(<#=typeName#> value) => throw new NotImplementedException();
    public static <#=typeName#> operator -(<#=typeName#> value) => throw new NotImplementedException();
    public static <#=typeName#> operator +(<#=typeName#> value) => throw new NotImplementedException();

    public override string ToString() 
    {
<# if (lanesA == 0) {#>
        return $"<{Nncase.Utilities.StringUtility.Join<T>(',', AsSpan())}>";
<#} else {#>
        var sb = new System.Text.StringBuilder();
        sb.Append("<");
        for (int i = 0; i < Height; i++)
        {
            sb.Append($"<{Nncase.Utilities.StringUtility.Join<T>(',', AsSpan(i))}>");
            if (i < Height - 1)
            {
                sb.Append(",");
            }
        }
        sb.Append(">");
        return sb.ToString();
<#}#>
    }

    public static <#=typeName#> Abs(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsCanonical(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsComplexNumber(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsEvenInteger(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsFinite(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsImaginaryNumber(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsInfinity(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsInteger(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsNaN(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsNegative(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsNegativeInfinity(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsNormal(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsOddInteger(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsPositive(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsPositiveInfinity(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsRealNumber(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsSubnormal(<#=typeName#> value) => throw new NotImplementedException();
    public static bool IsZero(<#=typeName#> value) => throw new NotImplementedException();
    public static <#=typeName#> MaxMagnitude(<#=typeName#> x, <#=typeName#> y) => throw new NotImplementedException();
    public static <#=typeName#> MaxMagnitudeNumber(<#=typeName#> x, <#=typeName#> y) => throw new NotImplementedException();
    public static <#=typeName#> MinMagnitude(<#=typeName#> x, <#=typeName#> y) => throw new NotImplementedException();
    public static <#=typeName#> MinMagnitudeNumber(<#=typeName#> x, <#=typeName#> y) => throw new NotImplementedException();
    public static <#=typeName#> Parse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider) => throw new NotImplementedException();
    public static <#=typeName#> Parse(string s, NumberStyles style, IFormatProvider provider) => throw new NotImplementedException();
    public static bool TryConvertFromChecked<TOther>(TOther value, [MaybeNullWhen(false)] out <#=typeName#> result) where TOther : INumberBase<TOther> => throw new NotImplementedException();
    public static bool TryConvertFromSaturating<TOther>(TOther value, [MaybeNullWhen(false)] out <#=typeName#> result) where TOther : INumberBase<TOther> => throw new NotImplementedException();
    public static bool TryConvertFromTruncating<TOther>(TOther value, [MaybeNullWhen(false)] out <#=typeName#> result) where TOther : INumberBase<TOther> => throw new NotImplementedException();
    public static bool TryConvertToChecked<TOther>(<#=typeName#> value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther> => throw new NotImplementedException();
    public static bool TryConvertToSaturating<TOther>(<#=typeName#> value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther> => throw new NotImplementedException();
    public static bool TryConvertToTruncating<TOther>(<#=typeName#> value, [MaybeNullWhen(false)] out TOther result) where TOther : INumberBase<TOther> => throw new NotImplementedException();
    public static bool TryParse(ReadOnlySpan<char> s, NumberStyles style, IFormatProvider provider, [MaybeNullWhen(false)] out <#=typeName#> result) => throw new NotImplementedException();
    public static bool TryParse([NotNullWhen(true)] string s, NumberStyles style, IFormatProvider provider, [MaybeNullWhen(false)] out <#=typeName#> result) => throw new NotImplementedException();
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format, IFormatProvider provider) => throw new NotImplementedException();
    public string ToString(string format, IFormatProvider formatProvider) => throw new NotImplementedException();
    public static <#=typeName#> Parse(ReadOnlySpan<char> s, IFormatProvider provider) => throw new NotImplementedException();
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider provider, [MaybeNullWhen(false)] out <#=typeName#> result) => throw new NotImplementedException();
    public static <#=typeName#> Parse(string s, IFormatProvider provider) => throw new NotImplementedException();
    public static bool TryParse([NotNullWhen(true)] string s, IFormatProvider provider, [MaybeNullWhen(false)] out <#=typeName#> result) => throw new NotImplementedException();
}

<#}#>