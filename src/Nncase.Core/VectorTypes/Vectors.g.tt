<#@ import namespace="System.Linq" #>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System.Collections;
using System.Runtime.InteropServices;
using Microsoft.Toolkit.HighPerformance;

namespace Nncase;

// NOTE fixed array not suppot generic

<# foreach (var lanes in new[] { 16, 32, 64 })
{
#>
[StructLayout(LayoutKind.Sequential)]
public unsafe struct Vector<#=lanes.ToString()#><T> : IEquatable<Vector<#=lanes.ToString()#><T>>
    where T : unmanaged, IEquatable<T>
{
<# foreach (var i in Enumerable.Range(0, lanes)) {#>
    private T _item<#=i.ToString()#>;
<#}#>

    public T this[int index]
    {
        get
        {
            fixed (T* ptr = &_item0)
            {
                return *(ptr + index);
            }
        }

        set
        {
            fixed (T* ptr = &_item0)
            {
                *(ptr + index) = value;
            }
        }
    }

    public T[] ToArray()
    {
        T[] values;

        fixed (T* ptr = &_item0)
        {
            var span = new Span<T>(ptr, Count);
            values = span.ToArray();
        }

        return values;
    }

    public bool Equals(Vector<#=lanes.ToString()#><T> other) {
      return <#=string.Join(" & ", Enumerable.Range(0, lanes).Select(i => $"_item{i.ToString()}.Equals(other._item{i.ToString()})"))#>;
    }

    public int Count => <#=lanes.ToString()#>;
}
<#}#>


<# foreach (var lanesA in new[] { 16, 32, 64 })
{
foreach (var lanesB in new[] { 16, 32, 64 })
{
#>
[StructLayout(LayoutKind.Sequential)]
public unsafe struct Vector<#=lanesA.ToString()#>x<#=lanesB.ToString()#><T> : IEquatable<Vector<#=lanesA.ToString()#>x<#=lanesB.ToString()#><T>>
    where T : unmanaged, IEquatable<T>
{
    // NOTE fixed buffer not suppot generic
<# foreach (var i in Enumerable.Range(0, lanesA)) {#>
<# foreach (var j in Enumerable.Range(0, lanesB)) {#>
    private T _item<#=i.ToString()#>_<#=j.ToString()#>;
<#}#>
<#}#>

    public T this[int i, int j]
    {
        get
        {
            fixed (T* ptr = &_item0_0)
            {
                return *(ptr + i * Width + j);
            }
        }

        set
        {
            fixed (T* ptr = &_item0_0)
            {
                *(ptr + i * Width + j) = value;
            }
        }
    }

    public T[,] ToArray()
    {
        T[,] values;

        fixed (T* ptr = &_item0_0)
        {
            var span = new Span2D<T>(ptr, Height, Width, 1);
            values = span.ToArray();
        }

        return values;
    }

    public int Height => <#=lanesA.ToString()#>;

    public int Width => <#=lanesB.ToString()#>;

    public int Count => Height * Width;

    public bool Equals(Vector<#=lanesA.ToString()#>x<#=lanesB.ToString()#><T> other) {
      return <# foreach (var i in Enumerable.Range(0, lanesA)) {#> <# foreach (var j in Enumerable.Range(0, lanesB)) {#> _item<#=i.ToString()#>_<#=j.ToString()#>.Equals(other._item<#=i.ToString()#>_<#=j.ToString()#>) & <#}#><#}#> true;
    }
}
<#}}#>
