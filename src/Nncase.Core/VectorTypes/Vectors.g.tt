<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System.Numerics;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using CommunityToolkit.HighPerformance;

namespace Nncase;

// NOTE fixed array not suppot generic

<# 
foreach (var lanesA in new[] { 0, 16, 32, 64 })
{
foreach (var lanesB in new[] { 2, 4, 8, 16, 32, 64 })
{
var typeName = lanesA == 0 ? $"Vector{lanesB.ToString()}<T>" : $"Vector{lanesA.ToString()}x{lanesB.ToString()}<T>";
#>
[StructLayout(LayoutKind.Sequential)]
public unsafe struct <#=typeName#> : IEquatable<<#=typeName#>>, IAdditionOperators<<#=typeName#>, <#=typeName#>, <#=typeName#>>, ISubtractionOperators<<#=typeName#>, <#=typeName#>, <#=typeName#>>, IMultiplyOperators<<#=typeName#>, <#=typeName#>, <#=typeName#>>, IDivisionOperators<<#=typeName#>, <#=typeName#>, <#=typeName#>>
    where T : unmanaged, IEquatable<T>, INumber<T>
{
<# if (lanesA == 0) {#>
<# foreach (var i in Enumerable.Range(0, lanesB)) { #>
    private T _item_0_<#=i#>;
<#}#>
<#} else {#>
<# foreach (var i in Enumerable.Range(0, lanesA)) { 
   foreach (var j in Enumerable.Range(0, lanesB)) {#>
    private T _item_<#=i#>_<#=j#>;
<#}}#>
<#}#>

    public static <#=typeName#> Create(T[<#=(lanesA == 0) ? "" : ","#>] array) {
      <#=typeName#> vec = default;
      var src = array.AsSpan<#= lanesA == 0 ? "" : "2D"#>();
      var dest = vec.AsSpan<#= lanesA == 0 ? "" : "2D"#>();
      src.CopyTo(dest);
      return vec;
    }

<# if (lanesA == 0) {#>
    public T this[int i]
    {
        get => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i);
        set => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i) = value;
    }
<#} else {#>
    public T this[int i, int j]
    {
        get => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i * Width + j);
        set => Unsafe.Add(ref Unsafe.AsRef(in _item_0_0), i * Width + j) = value;
    }
<#}#>

    public bool Equals(<#=typeName#> other) => AsSpan().SequenceEqual(other.AsSpan());

    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref Unsafe.AsRef(in _item_0_0), Count);

<# if (lanesA != 0) {#>
    public Span2D<T> AsSpan2D() => Span2D<T>.DangerousCreate(ref Unsafe.AsRef(in _item_0_0), Height, Width, 1);

    public int Height => <#=lanesA#>;

    public int Width => <#=lanesB#>;
    
    public int Count => Height * Width;
<# } else {#>
    public int Count => <#=lanesB#>;
<#}#>

<#foreach (var op in new string[] { "+", "-" , "*", "/" }) {#>
    public static <#=typeName#> operator <#=op#>(<#=typeName#> left, <#=typeName#> right) {
        <#=typeName#> res = default;
        var lhs = left.AsSpan();
        var rhs = right.AsSpan();
        var span = res.AsSpan();
        for (int i = 0; i < span.Length; i++)
        {
            span[i] = lhs[i] <#=op#> rhs[i];
        }
        return res;
    }

<#}#>
}

<#}}#>