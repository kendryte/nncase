
//---------------------------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated by T4 template.
//    Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//---------------------------------------------------------------------------------------------------

using System;
using System.Collections.Generic;
using System.Reactive;
using Nncase.IR;

namespace Nncase.PatternMatch;

internal partial class Matcher
{
    /// <inheritdoc/>
    protected override bool VisitCall(Call expr, IPattern pattern)
    {
        if (pattern is CallPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
                && Visit(expr.Target, exprPattern.Target)
                && VisitVArgsPattern(expr.Arguments, exprPattern.Arguments)
            ;
        }

        return DefaultVisit(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitFunction(Function expr, IPattern pattern)
    {
        if (pattern is FunctionPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
                && VisitVArgsPattern(expr.Parameters, exprPattern.Parameters)
                && Visit(expr.Body, exprPattern.Body)
            ;
        }

        return DefaultVisit(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitFusion(Fusion expr, IPattern pattern)
    {
        if (pattern is FusionPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
                && VisitVArgsPattern(expr.Parameters, exprPattern.Parameters)
                && Visit(expr.Body, exprPattern.Body)
            ;
        }

        return DefaultVisit(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitMarker(Marker expr, IPattern pattern)
    {
        if (pattern is MarkerPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
                && Visit(expr.Target, exprPattern.Target)
                && Visit(expr.Attribute, exprPattern.Attribute)
            ;
        }

        return DefaultVisit(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitTensorConst(TensorConst expr, IPattern pattern)
    {
        if (pattern is TensorConstPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
            ;
        }

        return VisitConst(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitTuple(IR.Tuple expr, IPattern pattern)
    {
        if (pattern is TuplePattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
                && VisitVArgsPattern(expr.Fields, exprPattern.Fields)
            ;
        }

        return DefaultVisit(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitTupleConst(TupleConst expr, IPattern pattern)
    {
        if (pattern is TupleConstPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
            ;
        }

        return VisitConst(expr, pattern);
    }

    /// <inheritdoc/>
    protected override bool VisitVar(Var expr, IPattern pattern)
    {
        if (pattern is VarPattern exprPattern)
        {
            return exprPattern.MatchLeaf(expr)
            ;
        }

        return DefaultVisit(expr, pattern);
    }

}
