/* This file is generated by tools/stackvm_gen/IsaGen at 06/01/2022 17:14:34 +08:00.
 *
 * Copyright 2019-2021 Canaan Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#pragma once
#include "../error.h"
#include "../result.h"
#include "../span_reader.h"
#include "opcode.h"

BEGIN_NS_NNCASE_RT_MODULE(stackvm)

template <class TOp>
struct op_reader;

template <>
struct op_reader<nop_op_t>
{
    nop_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        nop_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<br_op_t>
{
    br_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        br_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.target = reader.read_unaligned<int32_t>();
        return op;
    }
};

template <>
struct op_reader<br_true_op_t>
{
    br_true_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        br_true_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.target = reader.read_unaligned<int32_t>();
        return op;
    }
};

template <>
struct op_reader<br_false_op_t>
{
    br_false_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        br_false_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.target = reader.read_unaligned<int32_t>();
        return op;
    }
};

template <>
struct op_reader<ret_op_t>
{
    ret_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ret_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<call_op_t>
{
    call_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        call_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.args = reader.read_unaligned<uint8_t>();
        op.target = reader.read_unaligned<int32_t>();
        return op;
    }
};

template <>
struct op_reader<ecall_op_t>
{
    ecall_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ecall_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.args = reader.read_unaligned<uint8_t>();
        return op;
    }
};

template <>
struct op_reader<throw_op_t>
{
    throw_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        throw_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<break_op_t>
{
    break_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        break_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldc_i4_op_t>
{
    ldc_i4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldc_i4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.imm = reader.read_unaligned<int32_t>();
        return op;
    }
};

template <>
struct op_reader<ldnull_op_t>
{
    ldnull_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldnull_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldc_i4_0_op_t>
{
    ldc_i4_0_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldc_i4_0_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldc_i4_1_op_t>
{
    ldc_i4_1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldc_i4_1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldc_r4_op_t>
{
    ldc_r4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldc_r4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.imm = reader.read_unaligned<float>();
        return op;
    }
};

template <>
struct op_reader<ldind_i1_op_t>
{
    ldind_i1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_i1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_i2_op_t>
{
    ldind_i2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_i2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_i4_op_t>
{
    ldind_i4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_i4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_i_op_t>
{
    ldind_i_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_i_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_u1_op_t>
{
    ldind_u1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_u1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_u2_op_t>
{
    ldind_u2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_u2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_u4_op_t>
{
    ldind_u4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_u4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_u_op_t>
{
    ldind_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_br2_op_t>
{
    ldind_br2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_br2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldind_r4_op_t>
{
    ldind_r4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldind_r4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stind_i1_op_t>
{
    stind_i1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stind_i1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stind_i2_op_t>
{
    stind_i2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stind_i2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stind_i4_op_t>
{
    stind_i4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stind_i4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stind_i_op_t>
{
    stind_i_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stind_i_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stind_br2_op_t>
{
    stind_br2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stind_br2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stind_r4_op_t>
{
    stind_r4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stind_r4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<lea_gp_op_t>
{
    lea_gp_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        lea_gp_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.gpid = reader.read_unaligned<uint8_t>();
        op.offset = reader.read_unaligned<int32_t>();
        return op;
    }
};

template <>
struct op_reader<ldelem_i1_op_t>
{
    ldelem_i1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_i1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_i2_op_t>
{
    ldelem_i2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_i2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_i4_op_t>
{
    ldelem_i4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_i4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_i_op_t>
{
    ldelem_i_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_i_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_u1_op_t>
{
    ldelem_u1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_u1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_u2_op_t>
{
    ldelem_u2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_u2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_u4_op_t>
{
    ldelem_u4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_u4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_u_op_t>
{
    ldelem_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_br2_op_t>
{
    ldelem_br2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_br2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldelem_r4_op_t>
{
    ldelem_r4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldelem_r4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stelem_i1_op_t>
{
    stelem_i1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stelem_i1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stelem_i2_op_t>
{
    stelem_i2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stelem_i2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stelem_i4_op_t>
{
    stelem_i4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stelem_i4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stelem_i_op_t>
{
    stelem_i_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stelem_i_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stelem_br2_op_t>
{
    stelem_br2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stelem_br2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<stelem_r4_op_t>
{
    stelem_r4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stelem_r4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldarg_op_t>
{
    ldarg_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.index = reader.read_unaligned<uint16_t>();
        return op;
    }
};

template <>
struct op_reader<ldarg_0_op_t>
{
    ldarg_0_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_0_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldarg_1_op_t>
{
    ldarg_1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldarg_2_op_t>
{
    ldarg_2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldarg_3_op_t>
{
    ldarg_3_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_3_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldarg_4_op_t>
{
    ldarg_4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldarg_5_op_t>
{
    ldarg_5_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldarg_5_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldshape_op_t>
{
    ldshape_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldshape_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldstrides_op_t>
{
    ldstrides_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldstrides_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldtuple_elem_op_t>
{
    ldtuple_elem_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldtuple_elem_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldtuple_op_t>
{
    ldtuple_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldtuple_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<lddatatype_op_t>
{
    lddatatype_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        lddatatype_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldtensor_op_t>
{
    ldtensor_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldtensor_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ldlocal_op_t>
{
    ldlocal_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ldlocal_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.index = reader.read_unaligned<uint16_t>();
        return op;
    }
};

template <>
struct op_reader<stlocal_op_t>
{
    stlocal_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        stlocal_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.index = reader.read_unaligned<uint16_t>();
        return op;
    }
};

template <>
struct op_reader<dup_op_t>
{
    dup_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        dup_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<pop_op_t>
{
    pop_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        pop_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<neg_op_t>
{
    neg_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        neg_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<add_op_t>
{
    add_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        add_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<sub_op_t>
{
    sub_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        sub_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<mul_op_t>
{
    mul_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        mul_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<div_op_t>
{
    div_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        div_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<div_u_op_t>
{
    div_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        div_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<rem_op_t>
{
    rem_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        rem_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<rem_u_op_t>
{
    rem_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        rem_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<and_op_t>
{
    and_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        and_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<or_op_t>
{
    or_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        or_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<xor_op_t>
{
    xor_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        xor_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<not_op_t>
{
    not_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        not_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<shl_op_t>
{
    shl_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        shl_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<shr_op_t>
{
    shr_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        shr_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<shr_u_op_t>
{
    shr_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        shr_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<clt_op_t>
{
    clt_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        clt_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<clt_u_op_t>
{
    clt_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        clt_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cle_op_t>
{
    cle_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cle_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cle_u_op_t>
{
    cle_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cle_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<ceq_op_t>
{
    ceq_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        ceq_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cge_op_t>
{
    cge_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cge_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cge_u_op_t>
{
    cge_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cge_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cgt_op_t>
{
    cgt_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cgt_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cgt_u_op_t>
{
    cgt_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cgt_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<cne_op_t>
{
    cne_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        cne_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_i1_op_t>
{
    conv_i1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_i1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_i2_op_t>
{
    conv_i2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_i2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_i4_op_t>
{
    conv_i4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_i4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_i_op_t>
{
    conv_i_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_i_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_u1_op_t>
{
    conv_u1_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_u1_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_u2_op_t>
{
    conv_u2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_u2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_u4_op_t>
{
    conv_u4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_u4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_u_op_t>
{
    conv_u_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_u_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_br2_op_t>
{
    conv_br2_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_br2_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<conv_r4_op_t>
{
    conv_r4_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        conv_r4_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_batch_normalization_op_t>
{
    tensor_batch_normalization_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_batch_normalization_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_batch_to_space_op_t>
{
    tensor_batch_to_space_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_batch_to_space_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_binary_op_t>
{
    tensor_binary_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_binary_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.binary_op = static_cast<binary_op_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_broadcast_op_t>
{
    tensor_broadcast_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_broadcast_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_cast_op_t>
{
    tensor_cast_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_cast_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.new_type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_celu_op_t>
{
    tensor_celu_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_celu_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_clamp_op_t>
{
    tensor_clamp_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_clamp_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_compare_op_t>
{
    tensor_compare_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_compare_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.compare_op = static_cast<compare_op_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_concat_op_t>
{
    tensor_concat_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_concat_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_conv2d_op_t>
{
    tensor_conv2d_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_conv2d_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.pad_mode = static_cast<pad_mode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_conv2d_transpose_op_t>
{
    tensor_conv2d_transpose_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_conv2d_transpose_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.pad_mode = static_cast<pad_mode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_cum_sum_op_t>
{
    tensor_cum_sum_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_cum_sum_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_dequantize_op_t>
{
    tensor_dequantize_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_dequantize_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.target_type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_elu_op_t>
{
    tensor_elu_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_elu_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_expand_op_t>
{
    tensor_expand_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_expand_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_flatten_op_t>
{
    tensor_flatten_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_flatten_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_gather_op_t>
{
    tensor_gather_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_gather_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_gather_nd_op_t>
{
    tensor_gather_nd_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_gather_nd_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_get_item_op_t>
{
    tensor_get_item_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_get_item_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_hard_sigmoid_op_t>
{
    tensor_hard_sigmoid_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_hard_sigmoid_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_hard_swish_op_t>
{
    tensor_hard_swish_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_hard_swish_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_hardmax_op_t>
{
    tensor_hardmax_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_hardmax_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_instance_normalization_op_t>
{
    tensor_instance_normalization_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_instance_normalization_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_l2_normalization_op_t>
{
    tensor_l2_normalization_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_l2_normalization_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_leaky_relu_op_t>
{
    tensor_leaky_relu_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_leaky_relu_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_log_softmax_op_t>
{
    tensor_log_softmax_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_log_softmax_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_lp_normalization_op_t>
{
    tensor_lp_normalization_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_lp_normalization_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_lrn_op_t>
{
    tensor_lrn_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_lrn_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_lstm_op_t>
{
    tensor_lstm_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_lstm_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.direction = static_cast<lstmdirection_t>(reader.read_unaligned<uint32_t>());
        op.layout = static_cast<lstmlayout_t>(reader.read_unaligned<uint32_t>());
        op.activations = reader.read_string_array();
        return op;
    }
};

template <>
struct op_reader<tensor_mat_mul_op_t>
{
    tensor_mat_mul_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_mat_mul_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_normal_op_t>
{
    tensor_normal_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_normal_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_normal_like_op_t>
{
    tensor_normal_like_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_normal_like_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_one_hot_op_t>
{
    tensor_one_hot_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_one_hot_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.one_hot_mode = static_cast<one_hot_mode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_pad_op_t>
{
    tensor_pad_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_pad_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.pad_mode = static_cast<pad_mode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_prelu_op_t>
{
    tensor_prelu_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_prelu_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_prod_op_t>
{
    tensor_prod_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_prod_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_quant_param_of_op_t>
{
    tensor_quant_param_of_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_quant_param_of_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.quant_mode = static_cast<quant_mode_t>(reader.read_unaligned<uint32_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_quantize_op_t>
{
    tensor_quantize_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_quantize_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.target_type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_range_op_t>
{
    tensor_range_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_range_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_range_of_op_t>
{
    tensor_range_of_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_range_of_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_reduce_op_t>
{
    tensor_reduce_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_reduce_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.reduce_op = static_cast<reduce_op_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_reduce_arg_op_t>
{
    tensor_reduce_arg_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_reduce_arg_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.reduce_arg_op = static_cast<reduce_arg_op_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_reduce_window2d_op_t>
{
    tensor_reduce_window2d_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_reduce_window2d_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.reduce_op = static_cast<reduce_op_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_relu_op_t>
{
    tensor_relu_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_relu_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_relu6_op_t>
{
    tensor_relu6_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_relu6_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_require_op_t>
{
    tensor_require_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_require_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.message = reader.read_string();
        return op;
    }
};

template <>
struct op_reader<tensor_reshape_op_t>
{
    tensor_reshape_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_reshape_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_resize_image_op_t>
{
    tensor_resize_image_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_resize_image_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.resize_mode = static_cast<image_resize_mode_t>(reader.read_unaligned<uint8_t>());
        op.transformation_mode = static_cast<image_resize_transformation_mode_t>(reader.read_unaligned<uint32_t>());
        op.nearest_mode = static_cast<image_resize_nearest_mode_t>(reader.read_unaligned<uint32_t>());
        op.is_tfresize = reader.read_unaligned<bool>();
        return op;
    }
};

template <>
struct op_reader<tensor_reverse_sequence_op_t>
{
    tensor_reverse_sequence_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_reverse_sequence_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_select_op_t>
{
    tensor_select_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_select_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_selu_op_t>
{
    tensor_selu_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_selu_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_shape_of_op_t>
{
    tensor_shape_of_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_shape_of_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_sigmoid_op_t>
{
    tensor_sigmoid_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_sigmoid_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_size_of_op_t>
{
    tensor_size_of_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_size_of_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_slice_op_t>
{
    tensor_slice_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_slice_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_softmax_op_t>
{
    tensor_softmax_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_softmax_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_softplus_op_t>
{
    tensor_softplus_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_softplus_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_softsign_op_t>
{
    tensor_softsign_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_softsign_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_space_to_batch_op_t>
{
    tensor_space_to_batch_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_space_to_batch_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_split_op_t>
{
    tensor_split_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_split_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_squeeze_op_t>
{
    tensor_squeeze_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_squeeze_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_stack_op_t>
{
    tensor_stack_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_stack_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_tile_op_t>
{
    tensor_tile_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_tile_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_transpose_op_t>
{
    tensor_transpose_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_transpose_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_unary_op_t>
{
    tensor_unary_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_unary_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.unary_op = static_cast<unary_op_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_uniform_op_t>
{
    tensor_uniform_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_uniform_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_uniform_like_op_t>
{
    tensor_uniform_like_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_uniform_like_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        op.type = static_cast<typecode_t>(reader.read_unaligned<uint8_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_unsqueeze_op_t>
{
    tensor_unsqueeze_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_unsqueeze_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

template <>
struct op_reader<tensor_where_op_t>
{
    tensor_where_op_t operator()(NNCASE_UNUSED span_reader &reader) const
    {
        tensor_where_op_t op;
        op.opcode = static_cast<opcode_t>(reader.read_unaligned<uint8_t>());
        op.tensor_funct = static_cast<tensor_function_t>(reader.read_unaligned<uint16_t>());
        return op;
    }
};

class NNCASE_API op_visitor
{
public:
    op_visitor() noexcept
        : reader_({})
    {
    }

    ~op_visitor() = default;

    result<void> visit(gsl::span<const gsl::byte> text) noexcept;

    virtual result<void> visit(NNCASE_UNUSED const nop_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const br_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const br_true_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const br_false_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ret_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const call_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ecall_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const throw_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const break_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldc_i4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldnull_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldc_i4_0_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldc_i4_1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldc_r4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_i1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_i2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_i4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_i_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_u1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_u2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_u4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_br2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldind_r4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stind_i1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stind_i2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stind_i4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stind_i_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stind_br2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stind_r4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const lea_gp_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_i1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_i2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_i4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_i_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_u1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_u2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_u4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_br2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldelem_r4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stelem_i1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stelem_i2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stelem_i4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stelem_i_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stelem_br2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stelem_r4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_0_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_3_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldarg_5_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldshape_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldstrides_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldtuple_elem_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldtuple_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const lddatatype_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldtensor_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ldlocal_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const stlocal_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const dup_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const pop_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const neg_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const add_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const sub_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const mul_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const div_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const div_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const rem_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const rem_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const and_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const or_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const xor_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const not_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const shl_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const shr_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const shr_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const clt_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const clt_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cle_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cle_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const ceq_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cge_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cge_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cgt_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cgt_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const cne_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_i1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_i2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_i4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_i_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_u1_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_u2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_u4_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_u_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_br2_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const conv_r4_op_t &op) noexcept { return default_visit(op); }

    virtual result<void> visit(NNCASE_UNUSED const tensor_batch_normalization_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_batch_to_space_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_binary_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_broadcast_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_cast_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_celu_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_clamp_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_compare_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_concat_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_conv2d_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_conv2d_transpose_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_cum_sum_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_dequantize_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_elu_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_expand_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_flatten_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_gather_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_gather_nd_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_get_item_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_hard_sigmoid_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_hard_swish_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_hardmax_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_instance_normalization_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_l2_normalization_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_leaky_relu_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_log_softmax_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_lp_normalization_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_lrn_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_lstm_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_mat_mul_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_normal_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_normal_like_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_one_hot_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_pad_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_prelu_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_prod_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_quant_param_of_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_quantize_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_range_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_range_of_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_reduce_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_reduce_arg_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_reduce_window2d_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_relu_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_relu6_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_require_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_reshape_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_resize_image_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_reverse_sequence_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_select_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_selu_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_shape_of_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_sigmoid_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_size_of_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_slice_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_softmax_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_softplus_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_softsign_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_space_to_batch_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_split_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_squeeze_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_stack_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_tile_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_transpose_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_unary_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_uniform_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_uniform_like_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_unsqueeze_op_t &op) noexcept { return default_visit(op); }
    virtual result<void> visit(NNCASE_UNUSED const tensor_where_op_t &op) noexcept { return default_visit(op); }

protected:
    virtual result<void> default_visit(NNCASE_UNUSED const op_base_t &op) noexcept { return err(std::errc::not_supported); }

protected:
    bool interrupted_;
    span_reader reader_;

private:
    result<void> next() noexcept;
};

END_NS_NNCASE_RT_MODULE
