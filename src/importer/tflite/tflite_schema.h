/* Copyright 2019 Canaan Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
#define FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_

#include "flatbuffers/flatbuffers.h"

namespace tflite {

struct CustomQuantization;

struct QuantizationParameters;

struct Tensor;

struct Conv2DOptions;

struct Pool2DOptions;

struct DepthwiseConv2DOptions;

struct ConcatEmbeddingsOptions;

struct LSHProjectionOptions;

struct SVDFOptions;

struct RNNOptions;

struct SequenceRNNOptions;

struct BidirectionalSequenceRNNOptions;

struct FullyConnectedOptions;

struct SoftmaxOptions;

struct ConcatenationOptions;

struct AddOptions;

struct MulOptions;

struct L2NormOptions;

struct LocalResponseNormalizationOptions;

struct LSTMOptions;

struct UnidirectionalSequenceLSTMOptions;

struct BidirectionalSequenceLSTMOptions;

struct ResizeBilinearOptions;

struct ResizeNearestNeighborOptions;

struct CallOptions;

struct PadOptions;

struct PadV2Options;

struct ReshapeOptions;

struct SpaceToBatchNDOptions;

struct BatchToSpaceNDOptions;

struct SkipGramOptions;

struct SpaceToDepthOptions;

struct SubOptions;

struct DivOptions;

struct TopKV2Options;

struct EmbeddingLookupSparseOptions;

struct GatherOptions;

struct TransposeOptions;

struct ExpOptions;

struct CosOptions;

struct ReducerOptions;

struct SqueezeOptions;

struct SplitOptions;

struct SplitVOptions;

struct StridedSliceOptions;

struct LogSoftmaxOptions;

struct CastOptions;

struct DequantizeOptions;

struct MaximumMinimumOptions;

struct TileOptions;

struct ArgMaxOptions;

struct ArgMinOptions;

struct GreaterOptions;

struct GreaterEqualOptions;

struct LessOptions;

struct LessEqualOptions;

struct NegOptions;

struct SelectOptions;

struct SliceOptions;

struct TransposeConvOptions;

struct ExpandDimsOptions;

struct SparseToDenseOptions;

struct EqualOptions;

struct NotEqualOptions;

struct ShapeOptions;

struct RankOptions;

struct PowOptions;

struct FakeQuantOptions;

struct PackOptions;

struct LogicalOrOptions;

struct OneHotOptions;

struct AbsOptions;

struct LogicalAndOptions;

struct LogicalNotOptions;

struct UnpackOptions;

struct FloorDivOptions;

struct SquareOptions;

struct ZerosLikeOptions;

struct FillOptions;

struct FloorModOptions;

struct RangeOptions;

struct LeakyReluOptions;

struct SquaredDifferenceOptions;

struct MirrorPadOptions;

struct UniqueOptions;

struct ReverseV2Options;

struct AddNOptions;

struct GatherNdOptions;

struct WhereOptions;

struct ReverseSequenceOptions;

struct OperatorCode;

struct Operator;

struct SubGraph;

struct Buffer;

struct Model;

enum TensorType {
  TensorType_FLOAT32 = 0,
  TensorType_FLOAT16 = 1,
  TensorType_INT32 = 2,
  TensorType_UINT8 = 3,
  TensorType_INT64 = 4,
  TensorType_STRING = 5,
  TensorType_BOOL = 6,
  TensorType_INT16 = 7,
  TensorType_COMPLEX64 = 8,
  TensorType_INT8 = 9,
  TensorType_MIN = TensorType_FLOAT32,
  TensorType_MAX = TensorType_INT8
};

inline const TensorType (&EnumValuesTensorType())[10] {
  static const TensorType values[] = {
    TensorType_FLOAT32,
    TensorType_FLOAT16,
    TensorType_INT32,
    TensorType_UINT8,
    TensorType_INT64,
    TensorType_STRING,
    TensorType_BOOL,
    TensorType_INT16,
    TensorType_COMPLEX64,
    TensorType_INT8
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[] = {
    "FLOAT32",
    "FLOAT16",
    "INT32",
    "UINT8",
    "INT64",
    "STRING",
    "BOOL",
    "INT16",
    "COMPLEX64",
    "INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesTensorType()[index];
}

enum QuantizationDetails {
  QuantizationDetails_NONE = 0,
  QuantizationDetails_CustomQuantization = 1,
  QuantizationDetails_MIN = QuantizationDetails_NONE,
  QuantizationDetails_MAX = QuantizationDetails_CustomQuantization
};

inline const QuantizationDetails (&EnumValuesQuantizationDetails())[2] {
  static const QuantizationDetails values[] = {
    QuantizationDetails_NONE,
    QuantizationDetails_CustomQuantization
  };
  return values;
}

inline const char * const *EnumNamesQuantizationDetails() {
  static const char * const names[] = {
    "NONE",
    "CustomQuantization",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizationDetails(QuantizationDetails e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesQuantizationDetails()[index];
}

template<typename T> struct QuantizationDetailsTraits {
  static const QuantizationDetails enum_value = QuantizationDetails_NONE;
};

template<> struct QuantizationDetailsTraits<CustomQuantization> {
  static const QuantizationDetails enum_value = QuantizationDetails_CustomQuantization;
};

bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type);
bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum BuiltinOperator {
  BuiltinOperator_ADD = 0,
  BuiltinOperator_AVERAGE_POOL_2D = 1,
  BuiltinOperator_CONCATENATION = 2,
  BuiltinOperator_CONV_2D = 3,
  BuiltinOperator_DEPTHWISE_CONV_2D = 4,
  BuiltinOperator_DEQUANTIZE = 6,
  BuiltinOperator_EMBEDDING_LOOKUP = 7,
  BuiltinOperator_FLOOR = 8,
  BuiltinOperator_FULLY_CONNECTED = 9,
  BuiltinOperator_HASHTABLE_LOOKUP = 10,
  BuiltinOperator_L2_NORMALIZATION = 11,
  BuiltinOperator_L2_POOL_2D = 12,
  BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION = 13,
  BuiltinOperator_LOGISTIC = 14,
  BuiltinOperator_LSH_PROJECTION = 15,
  BuiltinOperator_LSTM = 16,
  BuiltinOperator_MAX_POOL_2D = 17,
  BuiltinOperator_MUL = 18,
  BuiltinOperator_RELU = 19,
  BuiltinOperator_RELU_N1_TO_1 = 20,
  BuiltinOperator_RELU6 = 21,
  BuiltinOperator_RESHAPE = 22,
  BuiltinOperator_RESIZE_BILINEAR = 23,
  BuiltinOperator_RNN = 24,
  BuiltinOperator_SOFTMAX = 25,
  BuiltinOperator_SPACE_TO_DEPTH = 26,
  BuiltinOperator_SVDF = 27,
  BuiltinOperator_TANH = 28,
  BuiltinOperator_CONCAT_EMBEDDINGS = 29,
  BuiltinOperator_SKIP_GRAM = 30,
  BuiltinOperator_CALL = 31,
  BuiltinOperator_CUSTOM = 32,
  BuiltinOperator_EMBEDDING_LOOKUP_SPARSE = 33,
  BuiltinOperator_PAD = 34,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  BuiltinOperator_GATHER = 36,
  BuiltinOperator_BATCH_TO_SPACE_ND = 37,
  BuiltinOperator_SPACE_TO_BATCH_ND = 38,
  BuiltinOperator_TRANSPOSE = 39,
  BuiltinOperator_MEAN = 40,
  BuiltinOperator_SUB = 41,
  BuiltinOperator_DIV = 42,
  BuiltinOperator_SQUEEZE = 43,
  BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  BuiltinOperator_STRIDED_SLICE = 45,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN = 46,
  BuiltinOperator_EXP = 47,
  BuiltinOperator_TOPK_V2 = 48,
  BuiltinOperator_SPLIT = 49,
  BuiltinOperator_LOG_SOFTMAX = 50,
  BuiltinOperator_DELEGATE = 51,
  BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  BuiltinOperator_CAST = 53,
  BuiltinOperator_PRELU = 54,
  BuiltinOperator_MAXIMUM = 55,
  BuiltinOperator_ARG_MAX = 56,
  BuiltinOperator_MINIMUM = 57,
  BuiltinOperator_LESS = 58,
  BuiltinOperator_NEG = 59,
  BuiltinOperator_PADV2 = 60,
  BuiltinOperator_GREATER = 61,
  BuiltinOperator_GREATER_EQUAL = 62,
  BuiltinOperator_LESS_EQUAL = 63,
  BuiltinOperator_SELECT = 64,
  BuiltinOperator_SLICE = 65,
  BuiltinOperator_SIN = 66,
  BuiltinOperator_TRANSPOSE_CONV = 67,
  BuiltinOperator_SPARSE_TO_DENSE = 68,
  BuiltinOperator_TILE = 69,
  BuiltinOperator_EXPAND_DIMS = 70,
  BuiltinOperator_EQUAL = 71,
  BuiltinOperator_NOT_EQUAL = 72,
  BuiltinOperator_LOG = 73,
  BuiltinOperator_SUM = 74,
  BuiltinOperator_SQRT = 75,
  BuiltinOperator_RSQRT = 76,
  BuiltinOperator_SHAPE = 77,
  BuiltinOperator_POW = 78,
  BuiltinOperator_ARG_MIN = 79,
  BuiltinOperator_FAKE_QUANT = 80,
  BuiltinOperator_REDUCE_PROD = 81,
  BuiltinOperator_REDUCE_MAX = 82,
  BuiltinOperator_PACK = 83,
  BuiltinOperator_LOGICAL_OR = 84,
  BuiltinOperator_ONE_HOT = 85,
  BuiltinOperator_LOGICAL_AND = 86,
  BuiltinOperator_LOGICAL_NOT = 87,
  BuiltinOperator_UNPACK = 88,
  BuiltinOperator_REDUCE_MIN = 89,
  BuiltinOperator_FLOOR_DIV = 90,
  BuiltinOperator_REDUCE_ANY = 91,
  BuiltinOperator_SQUARE = 92,
  BuiltinOperator_ZEROS_LIKE = 93,
  BuiltinOperator_FILL = 94,
  BuiltinOperator_FLOOR_MOD = 95,
  BuiltinOperator_RANGE = 96,
  BuiltinOperator_RESIZE_NEAREST_NEIGHBOR = 97,
  BuiltinOperator_LEAKY_RELU = 98,
  BuiltinOperator_SQUARED_DIFFERENCE = 99,
  BuiltinOperator_MIRROR_PAD = 100,
  BuiltinOperator_ABS = 101,
  BuiltinOperator_SPLIT_V = 102,
  BuiltinOperator_UNIQUE = 103,
  BuiltinOperator_CEIL = 104,
  BuiltinOperator_REVERSE_V2 = 105,
  BuiltinOperator_ADD_N = 106,
  BuiltinOperator_GATHER_ND = 107,
  BuiltinOperator_COS = 108,
  BuiltinOperator_WHERE = 109,
  BuiltinOperator_RANK = 110,
  BuiltinOperator_ELU = 111,
  BuiltinOperator_REVERSE_SEQUENCE = 112,
  BuiltinOperator_MIN = BuiltinOperator_ADD,
  BuiltinOperator_MAX = BuiltinOperator_REVERSE_SEQUENCE
};

inline const BuiltinOperator (&EnumValuesBuiltinOperator())[112] {
  static const BuiltinOperator values[] = {
    BuiltinOperator_ADD,
    BuiltinOperator_AVERAGE_POOL_2D,
    BuiltinOperator_CONCATENATION,
    BuiltinOperator_CONV_2D,
    BuiltinOperator_DEPTHWISE_CONV_2D,
    BuiltinOperator_DEQUANTIZE,
    BuiltinOperator_EMBEDDING_LOOKUP,
    BuiltinOperator_FLOOR,
    BuiltinOperator_FULLY_CONNECTED,
    BuiltinOperator_HASHTABLE_LOOKUP,
    BuiltinOperator_L2_NORMALIZATION,
    BuiltinOperator_L2_POOL_2D,
    BuiltinOperator_LOCAL_RESPONSE_NORMALIZATION,
    BuiltinOperator_LOGISTIC,
    BuiltinOperator_LSH_PROJECTION,
    BuiltinOperator_LSTM,
    BuiltinOperator_MAX_POOL_2D,
    BuiltinOperator_MUL,
    BuiltinOperator_RELU,
    BuiltinOperator_RELU_N1_TO_1,
    BuiltinOperator_RELU6,
    BuiltinOperator_RESHAPE,
    BuiltinOperator_RESIZE_BILINEAR,
    BuiltinOperator_RNN,
    BuiltinOperator_SOFTMAX,
    BuiltinOperator_SPACE_TO_DEPTH,
    BuiltinOperator_SVDF,
    BuiltinOperator_TANH,
    BuiltinOperator_CONCAT_EMBEDDINGS,
    BuiltinOperator_SKIP_GRAM,
    BuiltinOperator_CALL,
    BuiltinOperator_CUSTOM,
    BuiltinOperator_EMBEDDING_LOOKUP_SPARSE,
    BuiltinOperator_PAD,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_GATHER,
    BuiltinOperator_BATCH_TO_SPACE_ND,
    BuiltinOperator_SPACE_TO_BATCH_ND,
    BuiltinOperator_TRANSPOSE,
    BuiltinOperator_MEAN,
    BuiltinOperator_SUB,
    BuiltinOperator_DIV,
    BuiltinOperator_SQUEEZE,
    BuiltinOperator_UNIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_STRIDED_SLICE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_RNN,
    BuiltinOperator_EXP,
    BuiltinOperator_TOPK_V2,
    BuiltinOperator_SPLIT,
    BuiltinOperator_LOG_SOFTMAX,
    BuiltinOperator_DELEGATE,
    BuiltinOperator_BIDIRECTIONAL_SEQUENCE_LSTM,
    BuiltinOperator_CAST,
    BuiltinOperator_PRELU,
    BuiltinOperator_MAXIMUM,
    BuiltinOperator_ARG_MAX,
    BuiltinOperator_MINIMUM,
    BuiltinOperator_LESS,
    BuiltinOperator_NEG,
    BuiltinOperator_PADV2,
    BuiltinOperator_GREATER,
    BuiltinOperator_GREATER_EQUAL,
    BuiltinOperator_LESS_EQUAL,
    BuiltinOperator_SELECT,
    BuiltinOperator_SLICE,
    BuiltinOperator_SIN,
    BuiltinOperator_TRANSPOSE_CONV,
    BuiltinOperator_SPARSE_TO_DENSE,
    BuiltinOperator_TILE,
    BuiltinOperator_EXPAND_DIMS,
    BuiltinOperator_EQUAL,
    BuiltinOperator_NOT_EQUAL,
    BuiltinOperator_LOG,
    BuiltinOperator_SUM,
    BuiltinOperator_SQRT,
    BuiltinOperator_RSQRT,
    BuiltinOperator_SHAPE,
    BuiltinOperator_POW,
    BuiltinOperator_ARG_MIN,
    BuiltinOperator_FAKE_QUANT,
    BuiltinOperator_REDUCE_PROD,
    BuiltinOperator_REDUCE_MAX,
    BuiltinOperator_PACK,
    BuiltinOperator_LOGICAL_OR,
    BuiltinOperator_ONE_HOT,
    BuiltinOperator_LOGICAL_AND,
    BuiltinOperator_LOGICAL_NOT,
    BuiltinOperator_UNPACK,
    BuiltinOperator_REDUCE_MIN,
    BuiltinOperator_FLOOR_DIV,
    BuiltinOperator_REDUCE_ANY,
    BuiltinOperator_SQUARE,
    BuiltinOperator_ZEROS_LIKE,
    BuiltinOperator_FILL,
    BuiltinOperator_FLOOR_MOD,
    BuiltinOperator_RANGE,
    BuiltinOperator_RESIZE_NEAREST_NEIGHBOR,
    BuiltinOperator_LEAKY_RELU,
    BuiltinOperator_SQUARED_DIFFERENCE,
    BuiltinOperator_MIRROR_PAD,
    BuiltinOperator_ABS,
    BuiltinOperator_SPLIT_V,
    BuiltinOperator_UNIQUE,
    BuiltinOperator_CEIL,
    BuiltinOperator_REVERSE_V2,
    BuiltinOperator_ADD_N,
    BuiltinOperator_GATHER_ND,
    BuiltinOperator_COS,
    BuiltinOperator_WHERE,
    BuiltinOperator_RANK,
    BuiltinOperator_ELU,
    BuiltinOperator_REVERSE_SEQUENCE
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOperator() {
  static const char * const names[] = {
    "ADD",
    "AVERAGE_POOL_2D",
    "CONCATENATION",
    "CONV_2D",
    "DEPTHWISE_CONV_2D",
    "",
    "DEQUANTIZE",
    "EMBEDDING_LOOKUP",
    "FLOOR",
    "FULLY_CONNECTED",
    "HASHTABLE_LOOKUP",
    "L2_NORMALIZATION",
    "L2_POOL_2D",
    "LOCAL_RESPONSE_NORMALIZATION",
    "LOGISTIC",
    "LSH_PROJECTION",
    "LSTM",
    "MAX_POOL_2D",
    "MUL",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "RESHAPE",
    "RESIZE_BILINEAR",
    "RNN",
    "SOFTMAX",
    "SPACE_TO_DEPTH",
    "SVDF",
    "TANH",
    "CONCAT_EMBEDDINGS",
    "SKIP_GRAM",
    "CALL",
    "CUSTOM",
    "EMBEDDING_LOOKUP_SPARSE",
    "PAD",
    "UNIDIRECTIONAL_SEQUENCE_RNN",
    "GATHER",
    "BATCH_TO_SPACE_ND",
    "SPACE_TO_BATCH_ND",
    "TRANSPOSE",
    "MEAN",
    "SUB",
    "DIV",
    "SQUEEZE",
    "UNIDIRECTIONAL_SEQUENCE_LSTM",
    "STRIDED_SLICE",
    "BIDIRECTIONAL_SEQUENCE_RNN",
    "EXP",
    "TOPK_V2",
    "SPLIT",
    "LOG_SOFTMAX",
    "DELEGATE",
    "BIDIRECTIONAL_SEQUENCE_LSTM",
    "CAST",
    "PRELU",
    "MAXIMUM",
    "ARG_MAX",
    "MINIMUM",
    "LESS",
    "NEG",
    "PADV2",
    "GREATER",
    "GREATER_EQUAL",
    "LESS_EQUAL",
    "SELECT",
    "SLICE",
    "SIN",
    "TRANSPOSE_CONV",
    "SPARSE_TO_DENSE",
    "TILE",
    "EXPAND_DIMS",
    "EQUAL",
    "NOT_EQUAL",
    "LOG",
    "SUM",
    "SQRT",
    "RSQRT",
    "SHAPE",
    "POW",
    "ARG_MIN",
    "FAKE_QUANT",
    "REDUCE_PROD",
    "REDUCE_MAX",
    "PACK",
    "LOGICAL_OR",
    "ONE_HOT",
    "LOGICAL_AND",
    "LOGICAL_NOT",
    "UNPACK",
    "REDUCE_MIN",
    "FLOOR_DIV",
    "REDUCE_ANY",
    "SQUARE",
    "ZEROS_LIKE",
    "FILL",
    "FLOOR_MOD",
    "RANGE",
    "RESIZE_NEAREST_NEIGHBOR",
    "LEAKY_RELU",
    "SQUARED_DIFFERENCE",
    "MIRROR_PAD",
    "ABS",
    "SPLIT_V",
    "UNIQUE",
    "CEIL",
    "REVERSE_V2",
    "ADD_N",
    "GATHER_ND",
    "COS",
    "WHERE",
    "RANK",
    "ELU",
    "REVERSE_SEQUENCE",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOperator(BuiltinOperator e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBuiltinOperator()[index];
}

enum BuiltinOptions {
  BuiltinOptions_NONE = 0,
  BuiltinOptions_Conv2DOptions = 1,
  BuiltinOptions_DepthwiseConv2DOptions = 2,
  BuiltinOptions_ConcatEmbeddingsOptions = 3,
  BuiltinOptions_LSHProjectionOptions = 4,
  BuiltinOptions_Pool2DOptions = 5,
  BuiltinOptions_SVDFOptions = 6,
  BuiltinOptions_RNNOptions = 7,
  BuiltinOptions_FullyConnectedOptions = 8,
  BuiltinOptions_SoftmaxOptions = 9,
  BuiltinOptions_ConcatenationOptions = 10,
  BuiltinOptions_AddOptions = 11,
  BuiltinOptions_L2NormOptions = 12,
  BuiltinOptions_LocalResponseNormalizationOptions = 13,
  BuiltinOptions_LSTMOptions = 14,
  BuiltinOptions_ResizeBilinearOptions = 15,
  BuiltinOptions_CallOptions = 16,
  BuiltinOptions_ReshapeOptions = 17,
  BuiltinOptions_SkipGramOptions = 18,
  BuiltinOptions_SpaceToDepthOptions = 19,
  BuiltinOptions_EmbeddingLookupSparseOptions = 20,
  BuiltinOptions_MulOptions = 21,
  BuiltinOptions_PadOptions = 22,
  BuiltinOptions_GatherOptions = 23,
  BuiltinOptions_BatchToSpaceNDOptions = 24,
  BuiltinOptions_SpaceToBatchNDOptions = 25,
  BuiltinOptions_TransposeOptions = 26,
  BuiltinOptions_ReducerOptions = 27,
  BuiltinOptions_SubOptions = 28,
  BuiltinOptions_DivOptions = 29,
  BuiltinOptions_SqueezeOptions = 30,
  BuiltinOptions_SequenceRNNOptions = 31,
  BuiltinOptions_StridedSliceOptions = 32,
  BuiltinOptions_ExpOptions = 33,
  BuiltinOptions_TopKV2Options = 34,
  BuiltinOptions_SplitOptions = 35,
  BuiltinOptions_LogSoftmaxOptions = 36,
  BuiltinOptions_CastOptions = 37,
  BuiltinOptions_DequantizeOptions = 38,
  BuiltinOptions_MaximumMinimumOptions = 39,
  BuiltinOptions_ArgMaxOptions = 40,
  BuiltinOptions_LessOptions = 41,
  BuiltinOptions_NegOptions = 42,
  BuiltinOptions_PadV2Options = 43,
  BuiltinOptions_GreaterOptions = 44,
  BuiltinOptions_GreaterEqualOptions = 45,
  BuiltinOptions_LessEqualOptions = 46,
  BuiltinOptions_SelectOptions = 47,
  BuiltinOptions_SliceOptions = 48,
  BuiltinOptions_TransposeConvOptions = 49,
  BuiltinOptions_SparseToDenseOptions = 50,
  BuiltinOptions_TileOptions = 51,
  BuiltinOptions_ExpandDimsOptions = 52,
  BuiltinOptions_EqualOptions = 53,
  BuiltinOptions_NotEqualOptions = 54,
  BuiltinOptions_ShapeOptions = 55,
  BuiltinOptions_PowOptions = 56,
  BuiltinOptions_ArgMinOptions = 57,
  BuiltinOptions_FakeQuantOptions = 58,
  BuiltinOptions_PackOptions = 59,
  BuiltinOptions_LogicalOrOptions = 60,
  BuiltinOptions_OneHotOptions = 61,
  BuiltinOptions_LogicalAndOptions = 62,
  BuiltinOptions_LogicalNotOptions = 63,
  BuiltinOptions_UnpackOptions = 64,
  BuiltinOptions_FloorDivOptions = 65,
  BuiltinOptions_SquareOptions = 66,
  BuiltinOptions_ZerosLikeOptions = 67,
  BuiltinOptions_FillOptions = 68,
  BuiltinOptions_BidirectionalSequenceLSTMOptions = 69,
  BuiltinOptions_BidirectionalSequenceRNNOptions = 70,
  BuiltinOptions_UnidirectionalSequenceLSTMOptions = 71,
  BuiltinOptions_FloorModOptions = 72,
  BuiltinOptions_RangeOptions = 73,
  BuiltinOptions_ResizeNearestNeighborOptions = 74,
  BuiltinOptions_LeakyReluOptions = 75,
  BuiltinOptions_SquaredDifferenceOptions = 76,
  BuiltinOptions_MirrorPadOptions = 77,
  BuiltinOptions_AbsOptions = 78,
  BuiltinOptions_SplitVOptions = 79,
  BuiltinOptions_UniqueOptions = 80,
  BuiltinOptions_ReverseV2Options = 81,
  BuiltinOptions_AddNOptions = 82,
  BuiltinOptions_GatherNdOptions = 83,
  BuiltinOptions_CosOptions = 84,
  BuiltinOptions_WhereOptions = 85,
  BuiltinOptions_RankOptions = 86,
  BuiltinOptions_ReverseSequenceOptions = 87,
  BuiltinOptions_MIN = BuiltinOptions_NONE,
  BuiltinOptions_MAX = BuiltinOptions_ReverseSequenceOptions
};

inline const BuiltinOptions (&EnumValuesBuiltinOptions())[88] {
  static const BuiltinOptions values[] = {
    BuiltinOptions_NONE,
    BuiltinOptions_Conv2DOptions,
    BuiltinOptions_DepthwiseConv2DOptions,
    BuiltinOptions_ConcatEmbeddingsOptions,
    BuiltinOptions_LSHProjectionOptions,
    BuiltinOptions_Pool2DOptions,
    BuiltinOptions_SVDFOptions,
    BuiltinOptions_RNNOptions,
    BuiltinOptions_FullyConnectedOptions,
    BuiltinOptions_SoftmaxOptions,
    BuiltinOptions_ConcatenationOptions,
    BuiltinOptions_AddOptions,
    BuiltinOptions_L2NormOptions,
    BuiltinOptions_LocalResponseNormalizationOptions,
    BuiltinOptions_LSTMOptions,
    BuiltinOptions_ResizeBilinearOptions,
    BuiltinOptions_CallOptions,
    BuiltinOptions_ReshapeOptions,
    BuiltinOptions_SkipGramOptions,
    BuiltinOptions_SpaceToDepthOptions,
    BuiltinOptions_EmbeddingLookupSparseOptions,
    BuiltinOptions_MulOptions,
    BuiltinOptions_PadOptions,
    BuiltinOptions_GatherOptions,
    BuiltinOptions_BatchToSpaceNDOptions,
    BuiltinOptions_SpaceToBatchNDOptions,
    BuiltinOptions_TransposeOptions,
    BuiltinOptions_ReducerOptions,
    BuiltinOptions_SubOptions,
    BuiltinOptions_DivOptions,
    BuiltinOptions_SqueezeOptions,
    BuiltinOptions_SequenceRNNOptions,
    BuiltinOptions_StridedSliceOptions,
    BuiltinOptions_ExpOptions,
    BuiltinOptions_TopKV2Options,
    BuiltinOptions_SplitOptions,
    BuiltinOptions_LogSoftmaxOptions,
    BuiltinOptions_CastOptions,
    BuiltinOptions_DequantizeOptions,
    BuiltinOptions_MaximumMinimumOptions,
    BuiltinOptions_ArgMaxOptions,
    BuiltinOptions_LessOptions,
    BuiltinOptions_NegOptions,
    BuiltinOptions_PadV2Options,
    BuiltinOptions_GreaterOptions,
    BuiltinOptions_GreaterEqualOptions,
    BuiltinOptions_LessEqualOptions,
    BuiltinOptions_SelectOptions,
    BuiltinOptions_SliceOptions,
    BuiltinOptions_TransposeConvOptions,
    BuiltinOptions_SparseToDenseOptions,
    BuiltinOptions_TileOptions,
    BuiltinOptions_ExpandDimsOptions,
    BuiltinOptions_EqualOptions,
    BuiltinOptions_NotEqualOptions,
    BuiltinOptions_ShapeOptions,
    BuiltinOptions_PowOptions,
    BuiltinOptions_ArgMinOptions,
    BuiltinOptions_FakeQuantOptions,
    BuiltinOptions_PackOptions,
    BuiltinOptions_LogicalOrOptions,
    BuiltinOptions_OneHotOptions,
    BuiltinOptions_LogicalAndOptions,
    BuiltinOptions_LogicalNotOptions,
    BuiltinOptions_UnpackOptions,
    BuiltinOptions_FloorDivOptions,
    BuiltinOptions_SquareOptions,
    BuiltinOptions_ZerosLikeOptions,
    BuiltinOptions_FillOptions,
    BuiltinOptions_BidirectionalSequenceLSTMOptions,
    BuiltinOptions_BidirectionalSequenceRNNOptions,
    BuiltinOptions_UnidirectionalSequenceLSTMOptions,
    BuiltinOptions_FloorModOptions,
    BuiltinOptions_RangeOptions,
    BuiltinOptions_ResizeNearestNeighborOptions,
    BuiltinOptions_LeakyReluOptions,
    BuiltinOptions_SquaredDifferenceOptions,
    BuiltinOptions_MirrorPadOptions,
    BuiltinOptions_AbsOptions,
    BuiltinOptions_SplitVOptions,
    BuiltinOptions_UniqueOptions,
    BuiltinOptions_ReverseV2Options,
    BuiltinOptions_AddNOptions,
    BuiltinOptions_GatherNdOptions,
    BuiltinOptions_CosOptions,
    BuiltinOptions_WhereOptions,
    BuiltinOptions_RankOptions,
    BuiltinOptions_ReverseSequenceOptions
  };
  return values;
}

inline const char * const *EnumNamesBuiltinOptions() {
  static const char * const names[] = {
    "NONE",
    "Conv2DOptions",
    "DepthwiseConv2DOptions",
    "ConcatEmbeddingsOptions",
    "LSHProjectionOptions",
    "Pool2DOptions",
    "SVDFOptions",
    "RNNOptions",
    "FullyConnectedOptions",
    "SoftmaxOptions",
    "ConcatenationOptions",
    "AddOptions",
    "L2NormOptions",
    "LocalResponseNormalizationOptions",
    "LSTMOptions",
    "ResizeBilinearOptions",
    "CallOptions",
    "ReshapeOptions",
    "SkipGramOptions",
    "SpaceToDepthOptions",
    "EmbeddingLookupSparseOptions",
    "MulOptions",
    "PadOptions",
    "GatherOptions",
    "BatchToSpaceNDOptions",
    "SpaceToBatchNDOptions",
    "TransposeOptions",
    "ReducerOptions",
    "SubOptions",
    "DivOptions",
    "SqueezeOptions",
    "SequenceRNNOptions",
    "StridedSliceOptions",
    "ExpOptions",
    "TopKV2Options",
    "SplitOptions",
    "LogSoftmaxOptions",
    "CastOptions",
    "DequantizeOptions",
    "MaximumMinimumOptions",
    "ArgMaxOptions",
    "LessOptions",
    "NegOptions",
    "PadV2Options",
    "GreaterOptions",
    "GreaterEqualOptions",
    "LessEqualOptions",
    "SelectOptions",
    "SliceOptions",
    "TransposeConvOptions",
    "SparseToDenseOptions",
    "TileOptions",
    "ExpandDimsOptions",
    "EqualOptions",
    "NotEqualOptions",
    "ShapeOptions",
    "PowOptions",
    "ArgMinOptions",
    "FakeQuantOptions",
    "PackOptions",
    "LogicalOrOptions",
    "OneHotOptions",
    "LogicalAndOptions",
    "LogicalNotOptions",
    "UnpackOptions",
    "FloorDivOptions",
    "SquareOptions",
    "ZerosLikeOptions",
    "FillOptions",
    "BidirectionalSequenceLSTMOptions",
    "BidirectionalSequenceRNNOptions",
    "UnidirectionalSequenceLSTMOptions",
    "FloorModOptions",
    "RangeOptions",
    "ResizeNearestNeighborOptions",
    "LeakyReluOptions",
    "SquaredDifferenceOptions",
    "MirrorPadOptions",
    "AbsOptions",
    "SplitVOptions",
    "UniqueOptions",
    "ReverseV2Options",
    "AddNOptions",
    "GatherNdOptions",
    "CosOptions",
    "WhereOptions",
    "RankOptions",
    "ReverseSequenceOptions",
    nullptr
  };
  return names;
}

inline const char *EnumNameBuiltinOptions(BuiltinOptions e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesBuiltinOptions()[index];
}

template<typename T> struct BuiltinOptionsTraits {
  static const BuiltinOptions enum_value = BuiltinOptions_NONE;
};

template<> struct BuiltinOptionsTraits<Conv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Conv2DOptions;
};

template<> struct BuiltinOptionsTraits<DepthwiseConv2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DepthwiseConv2DOptions;
};

template<> struct BuiltinOptionsTraits<ConcatEmbeddingsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatEmbeddingsOptions;
};

template<> struct BuiltinOptionsTraits<LSHProjectionOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSHProjectionOptions;
};

template<> struct BuiltinOptionsTraits<Pool2DOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_Pool2DOptions;
};

template<> struct BuiltinOptionsTraits<SVDFOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SVDFOptions;
};

template<> struct BuiltinOptionsTraits<RNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RNNOptions;
};

template<> struct BuiltinOptionsTraits<FullyConnectedOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FullyConnectedOptions;
};

template<> struct BuiltinOptionsTraits<SoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<ConcatenationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ConcatenationOptions;
};

template<> struct BuiltinOptionsTraits<AddOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddOptions;
};

template<> struct BuiltinOptionsTraits<L2NormOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_L2NormOptions;
};

template<> struct BuiltinOptionsTraits<LocalResponseNormalizationOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LocalResponseNormalizationOptions;
};

template<> struct BuiltinOptionsTraits<LSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LSTMOptions;
};

template<> struct BuiltinOptionsTraits<ResizeBilinearOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeBilinearOptions;
};

template<> struct BuiltinOptionsTraits<CallOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CallOptions;
};

template<> struct BuiltinOptionsTraits<ReshapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReshapeOptions;
};

template<> struct BuiltinOptionsTraits<SkipGramOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SkipGramOptions;
};

template<> struct BuiltinOptionsTraits<SpaceToDepthOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToDepthOptions;
};

template<> struct BuiltinOptionsTraits<EmbeddingLookupSparseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EmbeddingLookupSparseOptions;
};

template<> struct BuiltinOptionsTraits<MulOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MulOptions;
};

template<> struct BuiltinOptionsTraits<PadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadOptions;
};

template<> struct BuiltinOptionsTraits<GatherOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherOptions;
};

template<> struct BuiltinOptionsTraits<BatchToSpaceNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BatchToSpaceNDOptions;
};

template<> struct BuiltinOptionsTraits<SpaceToBatchNDOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SpaceToBatchNDOptions;
};

template<> struct BuiltinOptionsTraits<TransposeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeOptions;
};

template<> struct BuiltinOptionsTraits<ReducerOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReducerOptions;
};

template<> struct BuiltinOptionsTraits<SubOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SubOptions;
};

template<> struct BuiltinOptionsTraits<DivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DivOptions;
};

template<> struct BuiltinOptionsTraits<SqueezeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SqueezeOptions;
};

template<> struct BuiltinOptionsTraits<SequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<StridedSliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_StridedSliceOptions;
};

template<> struct BuiltinOptionsTraits<ExpOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpOptions;
};

template<> struct BuiltinOptionsTraits<TopKV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_TopKV2Options;
};

template<> struct BuiltinOptionsTraits<SplitOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitOptions;
};

template<> struct BuiltinOptionsTraits<LogSoftmaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogSoftmaxOptions;
};

template<> struct BuiltinOptionsTraits<CastOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CastOptions;
};

template<> struct BuiltinOptionsTraits<DequantizeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_DequantizeOptions;
};

template<> struct BuiltinOptionsTraits<MaximumMinimumOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MaximumMinimumOptions;
};

template<> struct BuiltinOptionsTraits<ArgMaxOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMaxOptions;
};

template<> struct BuiltinOptionsTraits<LessOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessOptions;
};

template<> struct BuiltinOptionsTraits<NegOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NegOptions;
};

template<> struct BuiltinOptionsTraits<PadV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_PadV2Options;
};

template<> struct BuiltinOptionsTraits<GreaterOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterOptions;
};

template<> struct BuiltinOptionsTraits<GreaterEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GreaterEqualOptions;
};

template<> struct BuiltinOptionsTraits<LessEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LessEqualOptions;
};

template<> struct BuiltinOptionsTraits<SelectOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SelectOptions;
};

template<> struct BuiltinOptionsTraits<SliceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SliceOptions;
};

template<> struct BuiltinOptionsTraits<TransposeConvOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TransposeConvOptions;
};

template<> struct BuiltinOptionsTraits<SparseToDenseOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SparseToDenseOptions;
};

template<> struct BuiltinOptionsTraits<TileOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_TileOptions;
};

template<> struct BuiltinOptionsTraits<ExpandDimsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ExpandDimsOptions;
};

template<> struct BuiltinOptionsTraits<EqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_EqualOptions;
};

template<> struct BuiltinOptionsTraits<NotEqualOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_NotEqualOptions;
};

template<> struct BuiltinOptionsTraits<ShapeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ShapeOptions;
};

template<> struct BuiltinOptionsTraits<PowOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PowOptions;
};

template<> struct BuiltinOptionsTraits<ArgMinOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ArgMinOptions;
};

template<> struct BuiltinOptionsTraits<FakeQuantOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FakeQuantOptions;
};

template<> struct BuiltinOptionsTraits<PackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_PackOptions;
};

template<> struct BuiltinOptionsTraits<LogicalOrOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalOrOptions;
};

template<> struct BuiltinOptionsTraits<OneHotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_OneHotOptions;
};

template<> struct BuiltinOptionsTraits<LogicalAndOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalAndOptions;
};

template<> struct BuiltinOptionsTraits<LogicalNotOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LogicalNotOptions;
};

template<> struct BuiltinOptionsTraits<UnpackOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnpackOptions;
};

template<> struct BuiltinOptionsTraits<FloorDivOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorDivOptions;
};

template<> struct BuiltinOptionsTraits<SquareOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquareOptions;
};

template<> struct BuiltinOptionsTraits<ZerosLikeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ZerosLikeOptions;
};

template<> struct BuiltinOptionsTraits<FillOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FillOptions;
};

template<> struct BuiltinOptionsTraits<BidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<BidirectionalSequenceRNNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_BidirectionalSequenceRNNOptions;
};

template<> struct BuiltinOptionsTraits<UnidirectionalSequenceLSTMOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UnidirectionalSequenceLSTMOptions;
};

template<> struct BuiltinOptionsTraits<FloorModOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_FloorModOptions;
};

template<> struct BuiltinOptionsTraits<RangeOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RangeOptions;
};

template<> struct BuiltinOptionsTraits<ResizeNearestNeighborOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ResizeNearestNeighborOptions;
};

template<> struct BuiltinOptionsTraits<LeakyReluOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_LeakyReluOptions;
};

template<> struct BuiltinOptionsTraits<SquaredDifferenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SquaredDifferenceOptions;
};

template<> struct BuiltinOptionsTraits<MirrorPadOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_MirrorPadOptions;
};

template<> struct BuiltinOptionsTraits<AbsOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AbsOptions;
};

template<> struct BuiltinOptionsTraits<SplitVOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_SplitVOptions;
};

template<> struct BuiltinOptionsTraits<UniqueOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_UniqueOptions;
};

template<> struct BuiltinOptionsTraits<ReverseV2Options> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseV2Options;
};

template<> struct BuiltinOptionsTraits<AddNOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_AddNOptions;
};

template<> struct BuiltinOptionsTraits<GatherNdOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_GatherNdOptions;
};

template<> struct BuiltinOptionsTraits<CosOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_CosOptions;
};

template<> struct BuiltinOptionsTraits<WhereOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_WhereOptions;
};

template<> struct BuiltinOptionsTraits<RankOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_RankOptions;
};

template<> struct BuiltinOptionsTraits<ReverseSequenceOptions> {
  static const BuiltinOptions enum_value = BuiltinOptions_ReverseSequenceOptions;
};

bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type);
bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum Padding {
  Padding_SAME = 0,
  Padding_VALID = 1,
  Padding_MIN = Padding_SAME,
  Padding_MAX = Padding_VALID
};

inline const Padding (&EnumValuesPadding())[2] {
  static const Padding values[] = {
    Padding_SAME,
    Padding_VALID
  };
  return values;
}

inline const char * const *EnumNamesPadding() {
  static const char * const names[] = {
    "SAME",
    "VALID",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadding(Padding e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesPadding()[index];
}

enum ActivationFunctionType {
  ActivationFunctionType_NONE = 0,
  ActivationFunctionType_RELU = 1,
  ActivationFunctionType_RELU_N1_TO_1 = 2,
  ActivationFunctionType_RELU6 = 3,
  ActivationFunctionType_TANH = 4,
  ActivationFunctionType_SIGN_BIT = 5,
  ActivationFunctionType_MIN = ActivationFunctionType_NONE,
  ActivationFunctionType_MAX = ActivationFunctionType_SIGN_BIT
};

inline const ActivationFunctionType (&EnumValuesActivationFunctionType())[6] {
  static const ActivationFunctionType values[] = {
    ActivationFunctionType_NONE,
    ActivationFunctionType_RELU,
    ActivationFunctionType_RELU_N1_TO_1,
    ActivationFunctionType_RELU6,
    ActivationFunctionType_TANH,
    ActivationFunctionType_SIGN_BIT
  };
  return values;
}

inline const char * const *EnumNamesActivationFunctionType() {
  static const char * const names[] = {
    "NONE",
    "RELU",
    "RELU_N1_TO_1",
    "RELU6",
    "TANH",
    "SIGN_BIT",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationFunctionType(ActivationFunctionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesActivationFunctionType()[index];
}

enum LSHProjectionType {
  LSHProjectionType_UNKNOWN = 0,
  LSHProjectionType_SPARSE = 1,
  LSHProjectionType_DENSE = 2,
  LSHProjectionType_MIN = LSHProjectionType_UNKNOWN,
  LSHProjectionType_MAX = LSHProjectionType_DENSE
};

inline const LSHProjectionType (&EnumValuesLSHProjectionType())[3] {
  static const LSHProjectionType values[] = {
    LSHProjectionType_UNKNOWN,
    LSHProjectionType_SPARSE,
    LSHProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLSHProjectionType() {
  static const char * const names[] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSHProjectionType(LSHProjectionType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLSHProjectionType()[index];
}

enum FullyConnectedOptionsWeightsFormat {
  FullyConnectedOptionsWeightsFormat_DEFAULT = 0,
  FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8 = 1,
  FullyConnectedOptionsWeightsFormat_MIN = FullyConnectedOptionsWeightsFormat_DEFAULT,
  FullyConnectedOptionsWeightsFormat_MAX = FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
};

inline const FullyConnectedOptionsWeightsFormat (&EnumValuesFullyConnectedOptionsWeightsFormat())[2] {
  static const FullyConnectedOptionsWeightsFormat values[] = {
    FullyConnectedOptionsWeightsFormat_DEFAULT,
    FullyConnectedOptionsWeightsFormat_SHUFFLED4x16INT8
  };
  return values;
}

inline const char * const *EnumNamesFullyConnectedOptionsWeightsFormat() {
  static const char * const names[] = {
    "DEFAULT",
    "SHUFFLED4x16INT8",
    nullptr
  };
  return names;
}

inline const char *EnumNameFullyConnectedOptionsWeightsFormat(FullyConnectedOptionsWeightsFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesFullyConnectedOptionsWeightsFormat()[index];
}

enum LSTMKernelType {
  LSTMKernelType_FULL = 0,
  LSTMKernelType_BASIC = 1,
  LSTMKernelType_MIN = LSTMKernelType_FULL,
  LSTMKernelType_MAX = LSTMKernelType_BASIC
};

inline const LSTMKernelType (&EnumValuesLSTMKernelType())[2] {
  static const LSTMKernelType values[] = {
    LSTMKernelType_FULL,
    LSTMKernelType_BASIC
  };
  return values;
}

inline const char * const *EnumNamesLSTMKernelType() {
  static const char * const names[] = {
    "FULL",
    "BASIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameLSTMKernelType(LSTMKernelType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesLSTMKernelType()[index];
}

enum CombinerType {
  CombinerType_SUM = 0,
  CombinerType_MEAN = 1,
  CombinerType_SQRTN = 2,
  CombinerType_MIN = CombinerType_SUM,
  CombinerType_MAX = CombinerType_SQRTN
};

inline const CombinerType (&EnumValuesCombinerType())[3] {
  static const CombinerType values[] = {
    CombinerType_SUM,
    CombinerType_MEAN,
    CombinerType_SQRTN
  };
  return values;
}

inline const char * const *EnumNamesCombinerType() {
  static const char * const names[] = {
    "SUM",
    "MEAN",
    "SQRTN",
    nullptr
  };
  return names;
}

inline const char *EnumNameCombinerType(CombinerType e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCombinerType()[index];
}

enum MirrorPadMode {
  MirrorPadMode_REFLECT = 0,
  MirrorPadMode_SYMMETRIC = 1,
  MirrorPadMode_MIN = MirrorPadMode_REFLECT,
  MirrorPadMode_MAX = MirrorPadMode_SYMMETRIC
};

inline const MirrorPadMode (&EnumValuesMirrorPadMode())[2] {
  static const MirrorPadMode values[] = {
    MirrorPadMode_REFLECT,
    MirrorPadMode_SYMMETRIC
  };
  return values;
}

inline const char * const *EnumNamesMirrorPadMode() {
  static const char * const names[] = {
    "REFLECT",
    "SYMMETRIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameMirrorPadMode(MirrorPadMode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesMirrorPadMode()[index];
}

enum CustomOptionsFormat {
  CustomOptionsFormat_FLEXBUFFERS = 0,
  CustomOptionsFormat_MIN = CustomOptionsFormat_FLEXBUFFERS,
  CustomOptionsFormat_MAX = CustomOptionsFormat_FLEXBUFFERS
};

inline const CustomOptionsFormat (&EnumValuesCustomOptionsFormat())[1] {
  static const CustomOptionsFormat values[] = {
    CustomOptionsFormat_FLEXBUFFERS
  };
  return values;
}

inline const char * const *EnumNamesCustomOptionsFormat() {
  static const char * const names[] = {
    "FLEXBUFFERS",
    nullptr
  };
  return names;
}

inline const char *EnumNameCustomOptionsFormat(CustomOptionsFormat e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesCustomOptionsFormat()[index];
}

struct CustomQuantization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
};

struct CustomQuantizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(CustomQuantization::VT_CUSTOM, custom);
  }
  explicit CustomQuantizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomQuantizationBuilder &operator=(const CustomQuantizationBuilder &);
  flatbuffers::Offset<CustomQuantization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomQuantization>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantization(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomQuantizationBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<CustomQuantization> CreateCustomQuantizationDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  return tflite::CreateCustomQuantization(
      _fbb,
      custom ? _fbb.CreateVector<uint8_t>(*custom) : 0);
}

struct QuantizationParameters FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_SCALE = 8,
    VT_ZERO_POINT = 10,
    VT_DETAILS_TYPE = 12,
    VT_DETAILS = 14,
    VT_QUANTIZED_DIMENSION = 16
  };
  const flatbuffers::Vector<float> *min() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MIN);
  }
  const flatbuffers::Vector<float> *max() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_MAX);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  const flatbuffers::Vector<int64_t> *zero_point() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ZERO_POINT);
  }
  QuantizationDetails details_type() const {
    return static_cast<QuantizationDetails>(GetField<uint8_t>(VT_DETAILS_TYPE, 0));
  }
  const void *details() const {
    return GetPointer<const void *>(VT_DETAILS);
  }
  template<typename T> const T *details_as() const;
  const CustomQuantization *details_as_CustomQuantization() const {
    return details_type() == QuantizationDetails_CustomQuantization ? static_cast<const CustomQuantization *>(details()) : nullptr;
  }
  int32_t quantized_dimension() const {
    return GetField<int32_t>(VT_QUANTIZED_DIMENSION, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN) &&
           verifier.VerifyVector(min()) &&
           VerifyOffset(verifier, VT_MAX) &&
           verifier.VerifyVector(max()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyOffset(verifier, VT_ZERO_POINT) &&
           verifier.VerifyVector(zero_point()) &&
           VerifyField<uint8_t>(verifier, VT_DETAILS_TYPE) &&
           VerifyOffset(verifier, VT_DETAILS) &&
           VerifyQuantizationDetails(verifier, details(), details_type()) &&
           VerifyField<int32_t>(verifier, VT_QUANTIZED_DIMENSION) &&
           verifier.EndTable();
  }
};

template<> inline const CustomQuantization *QuantizationParameters::details_as<CustomQuantization>() const {
  return details_as_CustomQuantization();
}

struct QuantizationParametersBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(flatbuffers::Offset<flatbuffers::Vector<float>> min) {
    fbb_.AddOffset(QuantizationParameters::VT_MIN, min);
  }
  void add_max(flatbuffers::Offset<flatbuffers::Vector<float>> max) {
    fbb_.AddOffset(QuantizationParameters::VT_MAX, max);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(QuantizationParameters::VT_SCALE, scale);
  }
  void add_zero_point(flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point) {
    fbb_.AddOffset(QuantizationParameters::VT_ZERO_POINT, zero_point);
  }
  void add_details_type(QuantizationDetails details_type) {
    fbb_.AddElement<uint8_t>(QuantizationParameters::VT_DETAILS_TYPE, static_cast<uint8_t>(details_type), 0);
  }
  void add_details(flatbuffers::Offset<void> details) {
    fbb_.AddOffset(QuantizationParameters::VT_DETAILS, details);
  }
  void add_quantized_dimension(int32_t quantized_dimension) {
    fbb_.AddElement<int32_t>(QuantizationParameters::VT_QUANTIZED_DIMENSION, quantized_dimension, 0);
  }
  explicit QuantizationParametersBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantizationParametersBuilder &operator=(const QuantizationParametersBuilder &);
  flatbuffers::Offset<QuantizationParameters> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantizationParameters>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParameters(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<float>> min = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> max = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> zero_point = 0,
    QuantizationDetails details_type = QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  QuantizationParametersBuilder builder_(_fbb);
  builder_.add_quantized_dimension(quantized_dimension);
  builder_.add_details(details);
  builder_.add_zero_point(zero_point);
  builder_.add_scale(scale);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_details_type(details_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<QuantizationParameters> CreateQuantizationParametersDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<float> *min = nullptr,
    const std::vector<float> *max = nullptr,
    const std::vector<float> *scale = nullptr,
    const std::vector<int64_t> *zero_point = nullptr,
    QuantizationDetails details_type = QuantizationDetails_NONE,
    flatbuffers::Offset<void> details = 0,
    int32_t quantized_dimension = 0) {
  return tflite::CreateQuantizationParameters(
      _fbb,
      min ? _fbb.CreateVector<float>(*min) : 0,
      max ? _fbb.CreateVector<float>(*max) : 0,
      scale ? _fbb.CreateVector<float>(*scale) : 0,
      zero_point ? _fbb.CreateVector<int64_t>(*zero_point) : 0,
      details_type,
      details,
      quantized_dimension);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SHAPE = 4,
    VT_TYPE = 6,
    VT_BUFFER = 8,
    VT_NAME = 10,
    VT_QUANTIZATION = 12,
    VT_IS_VARIABLE = 14
  };
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  TensorType type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t buffer() const {
    return GetField<uint32_t>(VT_BUFFER, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const QuantizationParameters *quantization() const {
    return GetPointer<const QuantizationParameters *>(VT_QUANTIZATION);
  }
  bool is_variable() const {
    return GetField<uint8_t>(VT_IS_VARIABLE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_BUFFER) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANTIZATION) &&
           verifier.VerifyTable(quantization()) &&
           VerifyField<uint8_t>(verifier, VT_IS_VARIABLE) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_buffer(uint32_t buffer) {
    fbb_.AddElement<uint32_t>(Tensor::VT_BUFFER, buffer, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_quantization(flatbuffers::Offset<QuantizationParameters> quantization) {
    fbb_.AddOffset(Tensor::VT_QUANTIZATION, quantization);
  }
  void add_is_variable(bool is_variable) {
    fbb_.AddElement<uint8_t>(Tensor::VT_IS_VARIABLE, static_cast<uint8_t>(is_variable), 0);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    TensorType type = TensorType_FLOAT32,
    uint32_t buffer = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<QuantizationParameters> quantization = 0,
    bool is_variable = false) {
  TensorBuilder builder_(_fbb);
  builder_.add_quantization(quantization);
  builder_.add_name(name);
  builder_.add_buffer(buffer);
  builder_.add_shape(shape);
  builder_.add_is_variable(is_variable);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    TensorType type = TensorType_FLOAT32,
    uint32_t buffer = 0,
    const char *name = nullptr,
    flatbuffers::Offset<QuantizationParameters> quantization = 0,
    bool is_variable = false) {
  return tflite::CreateTensor(
      _fbb,
      shape ? _fbb.CreateVector<int32_t>(*shape) : 0,
      type,
      buffer,
      name ? _fbb.CreateString(name) : 0,
      quantization,
      is_variable);
}

struct Conv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FUSED_ACTIVATION_FUNCTION = 10,
    VT_DILATION_W_FACTOR = 12,
    VT_DILATION_H_FACTOR = 14
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
};

struct Conv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Conv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(Conv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit Conv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DOptionsBuilder &operator=(const Conv2DOptionsBuilder &);
  flatbuffers::Offset<Conv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DOptions> CreateConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  Conv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct Pool2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_FILTER_WIDTH = 10,
    VT_FILTER_HEIGHT = 12,
    VT_FUSED_ACTIVATION_FUNCTION = 14
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t filter_width() const {
    return GetField<int32_t>(VT_FILTER_WIDTH, 0);
  }
  int32_t filter_height() const {
    return GetField<int32_t>(VT_FILTER_HEIGHT, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_FILTER_WIDTH) &&
           VerifyField<int32_t>(verifier, VT_FILTER_HEIGHT) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct Pool2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_filter_width(int32_t filter_width) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_WIDTH, filter_width, 0);
  }
  void add_filter_height(int32_t filter_height) {
    fbb_.AddElement<int32_t>(Pool2DOptions::VT_FILTER_HEIGHT, filter_height, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(Pool2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit Pool2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Pool2DOptionsBuilder &operator=(const Pool2DOptionsBuilder &);
  flatbuffers::Offset<Pool2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pool2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pool2DOptions> CreatePool2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t filter_width = 0,
    int32_t filter_height = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  Pool2DOptionsBuilder builder_(_fbb);
  builder_.add_filter_height(filter_height);
  builder_.add_filter_width(filter_width);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct DepthwiseConv2DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8,
    VT_DEPTH_MULTIPLIER = 10,
    VT_FUSED_ACTIVATION_FUNCTION = 12,
    VT_DILATION_W_FACTOR = 14,
    VT_DILATION_H_FACTOR = 16
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  int32_t depth_multiplier() const {
    return GetField<int32_t>(VT_DEPTH_MULTIPLIER, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  int32_t dilation_w_factor() const {
    return GetField<int32_t>(VT_DILATION_W_FACTOR, 1);
  }
  int32_t dilation_h_factor() const {
    return GetField<int32_t>(VT_DILATION_H_FACTOR, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_MULTIPLIER) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int32_t>(verifier, VT_DILATION_W_FACTOR) &&
           VerifyField<int32_t>(verifier, VT_DILATION_H_FACTOR) &&
           verifier.EndTable();
  }
};

struct DepthwiseConv2DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_STRIDE_H, stride_h, 0);
  }
  void add_depth_multiplier(int32_t depth_multiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DEPTH_MULTIPLIER, depth_multiplier, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DepthwiseConv2DOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_dilation_w_factor(int32_t dilation_w_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_W_FACTOR, dilation_w_factor, 1);
  }
  void add_dilation_h_factor(int32_t dilation_h_factor) {
    fbb_.AddElement<int32_t>(DepthwiseConv2DOptions::VT_DILATION_H_FACTOR, dilation_h_factor, 1);
  }
  explicit DepthwiseConv2DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DOptionsBuilder &operator=(const DepthwiseConv2DOptionsBuilder &);
  flatbuffers::Offset<DepthwiseConv2DOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2DOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2DOptions> CreateDepthwiseConv2DOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0,
    int32_t depth_multiplier = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    int32_t dilation_w_factor = 1,
    int32_t dilation_h_factor = 1) {
  DepthwiseConv2DOptionsBuilder builder_(_fbb);
  builder_.add_dilation_h_factor(dilation_h_factor);
  builder_.add_dilation_w_factor(dilation_w_factor);
  builder_.add_depth_multiplier(depth_multiplier);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct ConcatEmbeddingsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM_CHANNELS = 4,
    VT_NUM_COLUMNS_PER_CHANNEL = 6,
    VT_EMBEDDING_DIM_PER_CHANNEL = 8
  };
  int32_t num_channels() const {
    return GetField<int32_t>(VT_NUM_CHANNELS, 0);
  }
  const flatbuffers::Vector<int32_t> *num_columns_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NUM_COLUMNS_PER_CHANNEL);
  }
  const flatbuffers::Vector<int32_t> *embedding_dim_per_channel() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_EMBEDDING_DIM_PER_CHANNEL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_CHANNELS) &&
           VerifyOffset(verifier, VT_NUM_COLUMNS_PER_CHANNEL) &&
           verifier.VerifyVector(num_columns_per_channel()) &&
           VerifyOffset(verifier, VT_EMBEDDING_DIM_PER_CHANNEL) &&
           verifier.VerifyVector(embedding_dim_per_channel()) &&
           verifier.EndTable();
  }
};

struct ConcatEmbeddingsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_channels(int32_t num_channels) {
    fbb_.AddElement<int32_t>(ConcatEmbeddingsOptions::VT_NUM_CHANNELS, num_channels, 0);
  }
  void add_num_columns_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_NUM_COLUMNS_PER_CHANNEL, num_columns_per_channel);
  }
  void add_embedding_dim_per_channel(flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel) {
    fbb_.AddOffset(ConcatEmbeddingsOptions::VT_EMBEDDING_DIM_PER_CHANNEL, embedding_dim_per_channel);
  }
  explicit ConcatEmbeddingsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatEmbeddingsOptionsBuilder &operator=(const ConcatEmbeddingsOptionsBuilder &);
  flatbuffers::Offset<ConcatEmbeddingsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatEmbeddingsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> num_columns_per_channel = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> embedding_dim_per_channel = 0) {
  ConcatEmbeddingsOptionsBuilder builder_(_fbb);
  builder_.add_embedding_dim_per_channel(embedding_dim_per_channel);
  builder_.add_num_columns_per_channel(num_columns_per_channel);
  builder_.add_num_channels(num_channels);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConcatEmbeddingsOptions> CreateConcatEmbeddingsOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_channels = 0,
    const std::vector<int32_t> *num_columns_per_channel = nullptr,
    const std::vector<int32_t> *embedding_dim_per_channel = nullptr) {
  return tflite::CreateConcatEmbeddingsOptions(
      _fbb,
      num_channels,
      num_columns_per_channel ? _fbb.CreateVector<int32_t>(*num_columns_per_channel) : 0,
      embedding_dim_per_channel ? _fbb.CreateVector<int32_t>(*embedding_dim_per_channel) : 0);
}

struct LSHProjectionOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4
  };
  LSHProjectionType type() const {
    return static_cast<LSHProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LSHProjectionOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LSHProjectionType type) {
    fbb_.AddElement<int8_t>(LSHProjectionOptions::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LSHProjectionOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSHProjectionOptionsBuilder &operator=(const LSHProjectionOptionsBuilder &);
  flatbuffers::Offset<LSHProjectionOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSHProjectionOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSHProjectionOptions> CreateLSHProjectionOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    LSHProjectionType type = LSHProjectionType_UNKNOWN) {
  LSHProjectionOptionsBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct SVDFOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RANK = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t rank() const {
    return GetField<int32_t>(VT_RANK, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RANK) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct SVDFOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rank(int32_t rank) {
    fbb_.AddElement<int32_t>(SVDFOptions::VT_RANK, rank, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SVDFOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit SVDFOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SVDFOptionsBuilder &operator=(const SVDFOptionsBuilder &);
  flatbuffers::Offset<SVDFOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SVDFOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SVDFOptions> CreateSVDFOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t rank = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  SVDFOptionsBuilder builder_(_fbb);
  builder_.add_rank(rank);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct RNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct RNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(RNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit RNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RNNOptionsBuilder &operator=(const RNNOptionsBuilder &);
  flatbuffers::Offset<RNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RNNOptions> CreateRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  RNNOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct SequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(SequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit SequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SequenceRNNOptionsBuilder &operator=(const SequenceRNNOptionsBuilder &);
  flatbuffers::Offset<SequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SequenceRNNOptions> CreateSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  SequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct BidirectionalSequenceRNNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TIME_MAJOR = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6,
    VT_MERGE_OUTPUTS = 8
  };
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           verifier.EndTable();
  }
};

struct BidirectionalSequenceRNNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceRNNOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceRNNOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  explicit BidirectionalSequenceRNNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceRNNOptionsBuilder &operator=(const BidirectionalSequenceRNNOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceRNNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceRNNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceRNNOptions> CreateBidirectionalSequenceRNNOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool time_major = false,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    bool merge_outputs = false) {
  BidirectionalSequenceRNNOptionsBuilder builder_(_fbb);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  builder_.add_time_major(time_major);
  return builder_.Finish();
}

struct FullyConnectedOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_WEIGHTS_FORMAT = 6
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  FullyConnectedOptionsWeightsFormat weights_format() const {
    return static_cast<FullyConnectedOptionsWeightsFormat>(GetField<int8_t>(VT_WEIGHTS_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<int8_t>(verifier, VT_WEIGHTS_FORMAT) &&
           verifier.EndTable();
  }
};

struct FullyConnectedOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_weights_format(FullyConnectedOptionsWeightsFormat weights_format) {
    fbb_.AddElement<int8_t>(FullyConnectedOptions::VT_WEIGHTS_FORMAT, static_cast<int8_t>(weights_format), 0);
  }
  explicit FullyConnectedOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullyConnectedOptionsBuilder &operator=(const FullyConnectedOptionsBuilder &);
  flatbuffers::Offset<FullyConnectedOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullyConnectedOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullyConnectedOptions> CreateFullyConnectedOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    FullyConnectedOptionsWeightsFormat weights_format = FullyConnectedOptionsWeightsFormat_DEFAULT) {
  FullyConnectedOptionsBuilder builder_(_fbb);
  builder_.add_weights_format(weights_format);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct SoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SoftmaxOptions::VT_BETA, beta, 0.0f);
  }
  explicit SoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxOptionsBuilder &operator=(const SoftmaxOptionsBuilder &);
  flatbuffers::Offset<SoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxOptions> CreateSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SoftmaxOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct ConcatenationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_AXIS = 4,
    VT_FUSED_ACTIVATION_FUNCTION = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct ConcatenationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ConcatenationOptions::VT_AXIS, axis, 0);
  }
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(ConcatenationOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit ConcatenationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatenationOptionsBuilder &operator=(const ConcatenationOptionsBuilder &);
  flatbuffers::Offset<ConcatenationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConcatenationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConcatenationOptions> CreateConcatenationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  ConcatenationOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct AddOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct AddOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(AddOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit AddOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddOptionsBuilder &operator=(const AddOptionsBuilder &);
  flatbuffers::Offset<AddOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddOptions> CreateAddOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  AddOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct MulOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct MulOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(MulOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit MulOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulOptionsBuilder &operator=(const MulOptionsBuilder &);
  flatbuffers::Offset<MulOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulOptions> CreateMulOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  MulOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct L2NormOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct L2NormOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(L2NormOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit L2NormOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormOptionsBuilder &operator=(const L2NormOptionsBuilder &);
  flatbuffers::Offset<L2NormOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2NormOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2NormOptions> CreateL2NormOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  L2NormOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct LocalResponseNormalizationOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t radius() const {
    return GetField<int32_t>(VT_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct LocalResponseNormalizationOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_radius(int32_t radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalizationOptions::VT_RADIUS, radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalizationOptions::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationOptionsBuilder &operator=(const LocalResponseNormalizationOptionsBuilder &);
  flatbuffers::Offset<LocalResponseNormalizationOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalizationOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalizationOptions> CreateLocalResponseNormalizationOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationOptionsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_radius(radius);
  return builder_.Finish();
}

struct LSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_KERNEL_TYPE = 10
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  LSTMKernelType kernel_type() const {
    return static_cast<LSTMKernelType>(GetField<int8_t>(VT_KERNEL_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<int8_t>(verifier, VT_KERNEL_TYPE) &&
           verifier.EndTable();
  }
};

struct LSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(LSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_kernel_type(LSTMKernelType kernel_type) {
    fbb_.AddElement<int8_t>(LSTMOptions::VT_KERNEL_TYPE, static_cast<int8_t>(kernel_type), 0);
  }
  explicit LSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LSTMOptionsBuilder &operator=(const LSTMOptionsBuilder &);
  flatbuffers::Offset<LSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LSTMOptions> CreateLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    LSTMKernelType kernel_type = LSTMKernelType_FULL) {
  LSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_kernel_type(kernel_type);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct UnidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_TIME_MAJOR = 10
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           verifier.EndTable();
  }
};

struct UnidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(UnidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(UnidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(UnidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 0);
  }
  explicit UnidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnidirectionalSequenceLSTMOptionsBuilder &operator=(const UnidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnidirectionalSequenceLSTMOptions> CreateUnidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool time_major = false) {
  UnidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_time_major(time_major);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct BidirectionalSequenceLSTMOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4,
    VT_CELL_CLIP = 6,
    VT_PROJ_CLIP = 8,
    VT_MERGE_OUTPUTS = 10,
    VT_TIME_MAJOR = 12
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  float cell_clip() const {
    return GetField<float>(VT_CELL_CLIP, 0.0f);
  }
  float proj_clip() const {
    return GetField<float>(VT_PROJ_CLIP, 0.0f);
  }
  bool merge_outputs() const {
    return GetField<uint8_t>(VT_MERGE_OUTPUTS, 0) != 0;
  }
  bool time_major() const {
    return GetField<uint8_t>(VT_TIME_MAJOR, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           VerifyField<float>(verifier, VT_CELL_CLIP) &&
           VerifyField<float>(verifier, VT_PROJ_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_MERGE_OUTPUTS) &&
           VerifyField<uint8_t>(verifier, VT_TIME_MAJOR) &&
           verifier.EndTable();
  }
};

struct BidirectionalSequenceLSTMOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(BidirectionalSequenceLSTMOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  void add_cell_clip(float cell_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_CELL_CLIP, cell_clip, 0.0f);
  }
  void add_proj_clip(float proj_clip) {
    fbb_.AddElement<float>(BidirectionalSequenceLSTMOptions::VT_PROJ_CLIP, proj_clip, 0.0f);
  }
  void add_merge_outputs(bool merge_outputs) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_MERGE_OUTPUTS, static_cast<uint8_t>(merge_outputs), 0);
  }
  void add_time_major(bool time_major) {
    fbb_.AddElement<uint8_t>(BidirectionalSequenceLSTMOptions::VT_TIME_MAJOR, static_cast<uint8_t>(time_major), 1);
  }
  explicit BidirectionalSequenceLSTMOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BidirectionalSequenceLSTMOptionsBuilder &operator=(const BidirectionalSequenceLSTMOptionsBuilder &);
  flatbuffers::Offset<BidirectionalSequenceLSTMOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BidirectionalSequenceLSTMOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BidirectionalSequenceLSTMOptions> CreateBidirectionalSequenceLSTMOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE,
    float cell_clip = 0.0f,
    float proj_clip = 0.0f,
    bool merge_outputs = false,
    bool time_major = true) {
  BidirectionalSequenceLSTMOptionsBuilder builder_(_fbb);
  builder_.add_proj_clip(proj_clip);
  builder_.add_cell_clip(cell_clip);
  builder_.add_time_major(time_major);
  builder_.add_merge_outputs(merge_outputs);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct ResizeBilinearOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALIGN_CORNERS = 8
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
};

struct ResizeBilinearOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeBilinearOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  explicit ResizeBilinearOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBilinearOptionsBuilder &operator=(const ResizeBilinearOptionsBuilder &);
  flatbuffers::Offset<ResizeBilinearOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeBilinearOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeBilinearOptions> CreateResizeBilinearOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false) {
  ResizeBilinearOptionsBuilder builder_(_fbb);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct ResizeNearestNeighborOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALIGN_CORNERS = 4
  };
  bool align_corners() const {
    return GetField<uint8_t>(VT_ALIGN_CORNERS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_ALIGN_CORNERS) &&
           verifier.EndTable();
  }
};

struct ResizeNearestNeighborOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_align_corners(bool align_corners) {
    fbb_.AddElement<uint8_t>(ResizeNearestNeighborOptions::VT_ALIGN_CORNERS, static_cast<uint8_t>(align_corners), 0);
  }
  explicit ResizeNearestNeighborOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeNearestNeighborOptionsBuilder &operator=(const ResizeNearestNeighborOptionsBuilder &);
  flatbuffers::Offset<ResizeNearestNeighborOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ResizeNearestNeighborOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ResizeNearestNeighborOptions> CreateResizeNearestNeighborOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool align_corners = false) {
  ResizeNearestNeighborOptionsBuilder builder_(_fbb);
  builder_.add_align_corners(align_corners);
  return builder_.Finish();
}

struct CallOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SUBGRAPH = 4
  };
  uint32_t subgraph() const {
    return GetField<uint32_t>(VT_SUBGRAPH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_SUBGRAPH) &&
           verifier.EndTable();
  }
};

struct CallOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subgraph(uint32_t subgraph) {
    fbb_.AddElement<uint32_t>(CallOptions::VT_SUBGRAPH, subgraph, 0);
  }
  explicit CallOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CallOptionsBuilder &operator=(const CallOptionsBuilder &);
  flatbuffers::Offset<CallOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CallOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CallOptions> CreateCallOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t subgraph = 0) {
  CallOptionsBuilder builder_(_fbb);
  builder_.add_subgraph(subgraph);
  return builder_.Finish();
}

struct PadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadOptionsBuilder &operator=(const PadOptionsBuilder &);
  flatbuffers::Offset<PadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadOptions> CreatePadOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PadV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PadV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PadV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadV2OptionsBuilder &operator=(const PadV2OptionsBuilder &);
  flatbuffers::Offset<PadV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PadV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<PadV2Options> CreatePadV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PadV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReshapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NEW_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *new_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NEW_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NEW_SHAPE) &&
           verifier.VerifyVector(new_shape()) &&
           verifier.EndTable();
  }
};

struct ReshapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_new_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape) {
    fbb_.AddOffset(ReshapeOptions::VT_NEW_SHAPE, new_shape);
  }
  explicit ReshapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeOptionsBuilder &operator=(const ReshapeOptionsBuilder &);
  flatbuffers::Offset<ReshapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReshapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> new_shape = 0) {
  ReshapeOptionsBuilder builder_(_fbb);
  builder_.add_new_shape(new_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<ReshapeOptions> CreateReshapeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *new_shape = nullptr) {
  return tflite::CreateReshapeOptions(
      _fbb,
      new_shape ? _fbb.CreateVector<int32_t>(*new_shape) : 0);
}

struct SpaceToBatchNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SpaceToBatchNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDOptionsBuilder &operator=(const SpaceToBatchNDOptionsBuilder &);
  flatbuffers::Offset<SpaceToBatchNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchNDOptions> CreateSpaceToBatchNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SpaceToBatchNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchToSpaceNDOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceNDOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchToSpaceNDOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDOptionsBuilder &operator=(const BatchToSpaceNDOptionsBuilder &);
  flatbuffers::Offset<BatchToSpaceNDOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceNDOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceNDOptions> CreateBatchToSpaceNDOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchToSpaceNDOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkipGramOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NGRAM_SIZE = 4,
    VT_MAX_SKIP_SIZE = 6,
    VT_INCLUDE_ALL_NGRAMS = 8
  };
  int32_t ngram_size() const {
    return GetField<int32_t>(VT_NGRAM_SIZE, 0);
  }
  int32_t max_skip_size() const {
    return GetField<int32_t>(VT_MAX_SKIP_SIZE, 0);
  }
  bool include_all_ngrams() const {
    return GetField<uint8_t>(VT_INCLUDE_ALL_NGRAMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NGRAM_SIZE) &&
           VerifyField<int32_t>(verifier, VT_MAX_SKIP_SIZE) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDE_ALL_NGRAMS) &&
           verifier.EndTable();
  }
};

struct SkipGramOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ngram_size(int32_t ngram_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_NGRAM_SIZE, ngram_size, 0);
  }
  void add_max_skip_size(int32_t max_skip_size) {
    fbb_.AddElement<int32_t>(SkipGramOptions::VT_MAX_SKIP_SIZE, max_skip_size, 0);
  }
  void add_include_all_ngrams(bool include_all_ngrams) {
    fbb_.AddElement<uint8_t>(SkipGramOptions::VT_INCLUDE_ALL_NGRAMS, static_cast<uint8_t>(include_all_ngrams), 0);
  }
  explicit SkipGramOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramOptionsBuilder &operator=(const SkipGramOptionsBuilder &);
  flatbuffers::Offset<SkipGramOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGramOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGramOptions> CreateSkipGramOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t ngram_size = 0,
    int32_t max_skip_size = 0,
    bool include_all_ngrams = false) {
  SkipGramOptionsBuilder builder_(_fbb);
  builder_.add_max_skip_size(max_skip_size);
  builder_.add_ngram_size(ngram_size);
  builder_.add_include_all_ngrams(include_all_ngrams);
  return builder_.Finish();
}

struct SpaceToDepthOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BLOCK_SIZE = 4
  };
  int32_t block_size() const {
    return GetField<int32_t>(VT_BLOCK_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCK_SIZE) &&
           verifier.EndTable();
  }
};

struct SpaceToDepthOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_block_size(int32_t block_size) {
    fbb_.AddElement<int32_t>(SpaceToDepthOptions::VT_BLOCK_SIZE, block_size, 0);
  }
  explicit SpaceToDepthOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthOptionsBuilder &operator=(const SpaceToDepthOptionsBuilder &);
  flatbuffers::Offset<SpaceToDepthOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepthOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepthOptions> CreateSpaceToDepthOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t block_size = 0) {
  SpaceToDepthOptionsBuilder builder_(_fbb);
  builder_.add_block_size(block_size);
  return builder_.Finish();
}

struct SubOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct SubOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(SubOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit SubOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubOptionsBuilder &operator=(const SubOptionsBuilder &);
  flatbuffers::Offset<SubOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubOptions> CreateSubOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  SubOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct DivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FUSED_ACTIVATION_FUNCTION = 4
  };
  ActivationFunctionType fused_activation_function() const {
    return static_cast<ActivationFunctionType>(GetField<int8_t>(VT_FUSED_ACTIVATION_FUNCTION, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_FUSED_ACTIVATION_FUNCTION) &&
           verifier.EndTable();
  }
};

struct DivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fused_activation_function(ActivationFunctionType fused_activation_function) {
    fbb_.AddElement<int8_t>(DivOptions::VT_FUSED_ACTIVATION_FUNCTION, static_cast<int8_t>(fused_activation_function), 0);
  }
  explicit DivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivOptionsBuilder &operator=(const DivOptionsBuilder &);
  flatbuffers::Offset<DivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivOptions> CreateDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationFunctionType fused_activation_function = ActivationFunctionType_NONE) {
  DivOptionsBuilder builder_(_fbb);
  builder_.add_fused_activation_function(fused_activation_function);
  return builder_.Finish();
}

struct TopKV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TopKV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TopKV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKV2OptionsBuilder &operator=(const TopKV2OptionsBuilder &);
  flatbuffers::Offset<TopKV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopKV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopKV2Options> CreateTopKV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TopKV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct EmbeddingLookupSparseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COMBINER = 4
  };
  CombinerType combiner() const {
    return static_cast<CombinerType>(GetField<int8_t>(VT_COMBINER, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_COMBINER) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupSparseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_combiner(CombinerType combiner) {
    fbb_.AddElement<int8_t>(EmbeddingLookupSparseOptions::VT_COMBINER, static_cast<int8_t>(combiner), 0);
  }
  explicit EmbeddingLookupSparseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseOptionsBuilder &operator=(const EmbeddingLookupSparseOptionsBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparseOptions> CreateEmbeddingLookupSparseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    CombinerType combiner = CombinerType_SUM) {
  EmbeddingLookupSparseOptionsBuilder builder_(_fbb);
  builder_.add_combiner(combiner);
  return builder_.Finish();
}

struct GatherOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct GatherOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(GatherOptions::VT_AXIS, axis, 0);
  }
  explicit GatherOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherOptionsBuilder &operator=(const GatherOptionsBuilder &);
  flatbuffers::Offset<GatherOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherOptions> CreateGatherOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  GatherOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct TransposeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TransposeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TransposeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeOptionsBuilder &operator=(const TransposeOptionsBuilder &);
  flatbuffers::Offset<TransposeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeOptions> CreateTransposeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TransposeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ExpOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExpOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpOptionsBuilder &operator=(const ExpOptionsBuilder &);
  flatbuffers::Offset<ExpOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpOptions> CreateExpOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CosOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CosOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosOptionsBuilder &operator=(const CosOptionsBuilder &);
  flatbuffers::Offset<CosOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CosOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CosOptions> CreateCosOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReducerOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEEP_DIMS = 4
  };
  bool keep_dims() const {
    return GetField<uint8_t>(VT_KEEP_DIMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_KEEP_DIMS) &&
           verifier.EndTable();
  }
};

struct ReducerOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keep_dims(bool keep_dims) {
    fbb_.AddElement<uint8_t>(ReducerOptions::VT_KEEP_DIMS, static_cast<uint8_t>(keep_dims), 0);
  }
  explicit ReducerOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReducerOptionsBuilder &operator=(const ReducerOptionsBuilder &);
  flatbuffers::Offset<ReducerOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReducerOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReducerOptions> CreateReducerOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool keep_dims = false) {
  ReducerOptionsBuilder builder_(_fbb);
  builder_.add_keep_dims(keep_dims);
  return builder_.Finish();
}

struct SqueezeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SQUEEZE_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *squeeze_dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SQUEEZE_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SQUEEZE_DIMS) &&
           verifier.VerifyVector(squeeze_dims()) &&
           verifier.EndTable();
  }
};

struct SqueezeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_squeeze_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims) {
    fbb_.AddOffset(SqueezeOptions::VT_SQUEEZE_DIMS, squeeze_dims);
  }
  explicit SqueezeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeOptionsBuilder &operator=(const SqueezeOptionsBuilder &);
  flatbuffers::Offset<SqueezeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SqueezeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> squeeze_dims = 0) {
  SqueezeOptionsBuilder builder_(_fbb);
  builder_.add_squeeze_dims(squeeze_dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<SqueezeOptions> CreateSqueezeOptionsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *squeeze_dims = nullptr) {
  return tflite::CreateSqueezeOptions(
      _fbb,
      squeeze_dims ? _fbb.CreateVector<int32_t>(*squeeze_dims) : 0);
}

struct SplitOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
};

struct SplitOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitOptionsBuilder &operator=(const SplitOptionsBuilder &);
  flatbuffers::Offset<SplitOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitOptions> CreateSplitOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct SplitVOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM_SPLITS = 4
  };
  int32_t num_splits() const {
    return GetField<int32_t>(VT_NUM_SPLITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM_SPLITS) &&
           verifier.EndTable();
  }
};

struct SplitVOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num_splits(int32_t num_splits) {
    fbb_.AddElement<int32_t>(SplitVOptions::VT_NUM_SPLITS, num_splits, 0);
  }
  explicit SplitVOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitVOptionsBuilder &operator=(const SplitVOptionsBuilder &);
  flatbuffers::Offset<SplitVOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SplitVOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SplitVOptions> CreateSplitVOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num_splits = 0) {
  SplitVOptionsBuilder builder_(_fbb);
  builder_.add_num_splits(num_splits);
  return builder_.Finish();
}

struct StridedSliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BEGIN_MASK = 4,
    VT_END_MASK = 6,
    VT_ELLIPSIS_MASK = 8,
    VT_NEW_AXIS_MASK = 10,
    VT_SHRINK_AXIS_MASK = 12
  };
  int32_t begin_mask() const {
    return GetField<int32_t>(VT_BEGIN_MASK, 0);
  }
  int32_t end_mask() const {
    return GetField<int32_t>(VT_END_MASK, 0);
  }
  int32_t ellipsis_mask() const {
    return GetField<int32_t>(VT_ELLIPSIS_MASK, 0);
  }
  int32_t new_axis_mask() const {
    return GetField<int32_t>(VT_NEW_AXIS_MASK, 0);
  }
  int32_t shrink_axis_mask() const {
    return GetField<int32_t>(VT_SHRINK_AXIS_MASK, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGIN_MASK) &&
           VerifyField<int32_t>(verifier, VT_END_MASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_NEW_AXIS_MASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINK_AXIS_MASK) &&
           verifier.EndTable();
  }
};

struct StridedSliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_begin_mask(int32_t begin_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_BEGIN_MASK, begin_mask, 0);
  }
  void add_end_mask(int32_t end_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_END_MASK, end_mask, 0);
  }
  void add_ellipsis_mask(int32_t ellipsis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_ELLIPSIS_MASK, ellipsis_mask, 0);
  }
  void add_new_axis_mask(int32_t new_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_NEW_AXIS_MASK, new_axis_mask, 0);
  }
  void add_shrink_axis_mask(int32_t shrink_axis_mask) {
    fbb_.AddElement<int32_t>(StridedSliceOptions::VT_SHRINK_AXIS_MASK, shrink_axis_mask, 0);
  }
  explicit StridedSliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceOptionsBuilder &operator=(const StridedSliceOptionsBuilder &);
  flatbuffers::Offset<StridedSliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSliceOptions> CreateStridedSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t begin_mask = 0,
    int32_t end_mask = 0,
    int32_t ellipsis_mask = 0,
    int32_t new_axis_mask = 0,
    int32_t shrink_axis_mask = 0) {
  StridedSliceOptionsBuilder builder_(_fbb);
  builder_.add_shrink_axis_mask(shrink_axis_mask);
  builder_.add_new_axis_mask(new_axis_mask);
  builder_.add_ellipsis_mask(ellipsis_mask);
  builder_.add_end_mask(end_mask);
  builder_.add_begin_mask(begin_mask);
  return builder_.Finish();
}

struct LogSoftmaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogSoftmaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogSoftmaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogSoftmaxOptionsBuilder &operator=(const LogSoftmaxOptionsBuilder &);
  flatbuffers::Offset<LogSoftmaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogSoftmaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogSoftmaxOptions> CreateLogSoftmaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogSoftmaxOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CastOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IN_DATA_TYPE = 4,
    VT_OUT_DATA_TYPE = 6
  };
  TensorType in_data_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_IN_DATA_TYPE, 0));
  }
  TensorType out_data_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUT_DATA_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IN_DATA_TYPE) &&
           VerifyField<int8_t>(verifier, VT_OUT_DATA_TYPE) &&
           verifier.EndTable();
  }
};

struct CastOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_in_data_type(TensorType in_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_IN_DATA_TYPE, static_cast<int8_t>(in_data_type), 0);
  }
  void add_out_data_type(TensorType out_data_type) {
    fbb_.AddElement<int8_t>(CastOptions::VT_OUT_DATA_TYPE, static_cast<int8_t>(out_data_type), 0);
  }
  explicit CastOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastOptionsBuilder &operator=(const CastOptionsBuilder &);
  flatbuffers::Offset<CastOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CastOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<CastOptions> CreateCastOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType in_data_type = TensorType_FLOAT32,
    TensorType out_data_type = TensorType_FLOAT32) {
  CastOptionsBuilder builder_(_fbb);
  builder_.add_out_data_type(out_data_type);
  builder_.add_in_data_type(in_data_type);
  return builder_.Finish();
}

struct DequantizeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DequantizeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DequantizeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DequantizeOptionsBuilder &operator=(const DequantizeOptionsBuilder &);
  flatbuffers::Offset<DequantizeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DequantizeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<DequantizeOptions> CreateDequantizeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DequantizeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MaximumMinimumOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MaximumMinimumOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumMinimumOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumMinimumOptionsBuilder &operator=(const MaximumMinimumOptionsBuilder &);
  flatbuffers::Offset<MaximumMinimumOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumMinimumOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumMinimumOptions> CreateMaximumMinimumOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumMinimumOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TileOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TileOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TileOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileOptionsBuilder &operator=(const TileOptionsBuilder &);
  flatbuffers::Offset<TileOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TileOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TileOptions> CreateTileOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TileOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ArgMaxOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OUTPUT_TYPE = 4
  };
  TensorType output_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
};

struct ArgMaxOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMaxOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMaxOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxOptionsBuilder &operator=(const ArgMaxOptionsBuilder &);
  flatbuffers::Offset<ArgMaxOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMaxOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMaxOptions> CreateArgMaxOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType output_type = TensorType_FLOAT32) {
  ArgMaxOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct ArgMinOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OUTPUT_TYPE = 4
  };
  TensorType output_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUTPUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUTPUT_TYPE) &&
           verifier.EndTable();
  }
};

struct ArgMinOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_type(TensorType output_type) {
    fbb_.AddElement<int8_t>(ArgMinOptions::VT_OUTPUT_TYPE, static_cast<int8_t>(output_type), 0);
  }
  explicit ArgMinOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinOptionsBuilder &operator=(const ArgMinOptionsBuilder &);
  flatbuffers::Offset<ArgMinOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMinOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMinOptions> CreateArgMinOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType output_type = TensorType_FLOAT32) {
  ArgMinOptionsBuilder builder_(_fbb);
  builder_.add_output_type(output_type);
  return builder_.Finish();
}

struct GreaterOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterOptionsBuilder &operator=(const GreaterOptionsBuilder &);
  flatbuffers::Offset<GreaterOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterOptions> CreateGreaterOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualOptionsBuilder &operator=(const GreaterEqualOptionsBuilder &);
  flatbuffers::Offset<GreaterEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqualOptions> CreateGreaterEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessOptionsBuilder &operator=(const LessOptionsBuilder &);
  flatbuffers::Offset<LessOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessOptions> CreateLessOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualOptionsBuilder &operator=(const LessEqualOptionsBuilder &);
  flatbuffers::Offset<LessEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqualOptions> CreateLessEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NegOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegOptionsBuilder &operator=(const NegOptionsBuilder &);
  flatbuffers::Offset<NegOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegOptions> CreateNegOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SelectOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SelectOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectOptionsBuilder &operator=(const SelectOptionsBuilder &);
  flatbuffers::Offset<SelectOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SelectOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SelectOptions> CreateSelectOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SliceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SliceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SliceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceOptionsBuilder &operator=(const SliceOptionsBuilder &);
  flatbuffers::Offset<SliceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SliceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SliceOptions> CreateSliceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SliceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TransposeConvOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PADDING = 4,
    VT_STRIDE_W = 6,
    VT_STRIDE_H = 8
  };
  Padding padding() const {
    return static_cast<Padding>(GetField<int8_t>(VT_PADDING, 0));
  }
  int32_t stride_w() const {
    return GetField<int32_t>(VT_STRIDE_W, 0);
  }
  int32_t stride_h() const {
    return GetField<int32_t>(VT_STRIDE_H, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_PADDING) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_W) &&
           VerifyField<int32_t>(verifier, VT_STRIDE_H) &&
           verifier.EndTable();
  }
};

struct TransposeConvOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_padding(Padding padding) {
    fbb_.AddElement<int8_t>(TransposeConvOptions::VT_PADDING, static_cast<int8_t>(padding), 0);
  }
  void add_stride_w(int32_t stride_w) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_W, stride_w, 0);
  }
  void add_stride_h(int32_t stride_h) {
    fbb_.AddElement<int32_t>(TransposeConvOptions::VT_STRIDE_H, stride_h, 0);
  }
  explicit TransposeConvOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeConvOptionsBuilder &operator=(const TransposeConvOptionsBuilder &);
  flatbuffers::Offset<TransposeConvOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TransposeConvOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<TransposeConvOptions> CreateTransposeConvOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    Padding padding = Padding_SAME,
    int32_t stride_w = 0,
    int32_t stride_h = 0) {
  TransposeConvOptionsBuilder builder_(_fbb);
  builder_.add_stride_h(stride_h);
  builder_.add_stride_w(stride_w);
  builder_.add_padding(padding);
  return builder_.Finish();
}

struct ExpandDimsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ExpandDimsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ExpandDimsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsOptionsBuilder &operator=(const ExpandDimsOptionsBuilder &);
  flatbuffers::Offset<ExpandDimsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDimsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDimsOptions> CreateExpandDimsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ExpandDimsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SparseToDenseOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALIDATE_INDICES = 4
  };
  bool validate_indices() const {
    return GetField<uint8_t>(VT_VALIDATE_INDICES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATE_INDICES) &&
           verifier.EndTable();
  }
};

struct SparseToDenseOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validate_indices(bool validate_indices) {
    fbb_.AddElement<uint8_t>(SparseToDenseOptions::VT_VALIDATE_INDICES, static_cast<uint8_t>(validate_indices), 0);
  }
  explicit SparseToDenseOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseOptionsBuilder &operator=(const SparseToDenseOptionsBuilder &);
  flatbuffers::Offset<SparseToDenseOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDenseOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDenseOptions> CreateSparseToDenseOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validate_indices = false) {
  SparseToDenseOptionsBuilder builder_(_fbb);
  builder_.add_validate_indices(validate_indices);
  return builder_.Finish();
}

struct EqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualOptionsBuilder &operator=(const EqualOptionsBuilder &);
  flatbuffers::Offset<EqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<EqualOptions> CreateEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqualOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NotEqualOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualOptionsBuilder &operator=(const NotEqualOptionsBuilder &);
  flatbuffers::Offset<NotEqualOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqualOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqualOptions> CreateNotEqualOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ShapeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OUT_TYPE = 4
  };
  TensorType out_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_OUT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_OUT_TYPE) &&
           verifier.EndTable();
  }
};

struct ShapeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_out_type(TensorType out_type) {
    fbb_.AddElement<int8_t>(ShapeOptions::VT_OUT_TYPE, static_cast<int8_t>(out_type), 0);
  }
  explicit ShapeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeOptionsBuilder &operator=(const ShapeOptionsBuilder &);
  flatbuffers::Offset<ShapeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ShapeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ShapeOptions> CreateShapeOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType out_type = TensorType_FLOAT32) {
  ShapeOptionsBuilder builder_(_fbb);
  builder_.add_out_type(out_type);
  return builder_.Finish();
}

struct RankOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RankOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankOptionsBuilder &operator=(const RankOptionsBuilder &);
  flatbuffers::Offset<RankOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RankOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RankOptions> CreateRankOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PowOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct PowOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit PowOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowOptionsBuilder &operator=(const PowOptionsBuilder &);
  flatbuffers::Offset<PowOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowOptions> CreatePowOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  PowOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MIN = 4,
    VT_MAX = 6,
    VT_NUM_BITS = 8,
    VT_NARROW_RANGE = 10
  };
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  int32_t num_bits() const {
    return GetField<int32_t>(VT_NUM_BITS, 0);
  }
  bool narrow_range() const {
    return GetField<uint8_t>(VT_NARROW_RANGE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MIN) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<int32_t>(verifier, VT_NUM_BITS) &&
           VerifyField<uint8_t>(verifier, VT_NARROW_RANGE) &&
           verifier.EndTable();
  }
};

struct FakeQuantOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min(float min) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MIN, min, 0.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(FakeQuantOptions::VT_MAX, max, 0.0f);
  }
  void add_num_bits(int32_t num_bits) {
    fbb_.AddElement<int32_t>(FakeQuantOptions::VT_NUM_BITS, num_bits, 0);
  }
  void add_narrow_range(bool narrow_range) {
    fbb_.AddElement<uint8_t>(FakeQuantOptions::VT_NARROW_RANGE, static_cast<uint8_t>(narrow_range), 0);
  }
  explicit FakeQuantOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantOptionsBuilder &operator=(const FakeQuantOptionsBuilder &);
  flatbuffers::Offset<FakeQuantOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantOptions> CreateFakeQuantOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float min = 0.0f,
    float max = 0.0f,
    int32_t num_bits = 0,
    bool narrow_range = false) {
  FakeQuantOptionsBuilder builder_(_fbb);
  builder_.add_num_bits(num_bits);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_narrow_range(narrow_range);
  return builder_.Finish();
}

struct PackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUES_COUNT = 4,
    VT_AXIS = 6
  };
  int32_t values_count() const {
    return GetField<int32_t>(VT_VALUES_COUNT, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUES_COUNT) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct PackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_values_count(int32_t values_count) {
    fbb_.AddElement<int32_t>(PackOptions::VT_VALUES_COUNT, values_count, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(PackOptions::VT_AXIS, axis, 0);
  }
  explicit PackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PackOptionsBuilder &operator=(const PackOptionsBuilder &);
  flatbuffers::Offset<PackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<PackOptions> CreatePackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t values_count = 0,
    int32_t axis = 0) {
  PackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_values_count(values_count);
  return builder_.Finish();
}

struct LogicalOrOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalOrOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrOptionsBuilder &operator=(const LogicalOrOptionsBuilder &);
  flatbuffers::Offset<LogicalOrOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOrOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOrOptions> CreateLogicalOrOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OneHotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct OneHotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHotOptions::VT_AXIS, axis, 0);
  }
  explicit OneHotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotOptionsBuilder &operator=(const OneHotOptionsBuilder &);
  flatbuffers::Offset<OneHotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHotOptions> CreateOneHotOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct AbsOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AbsOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsOptionsBuilder &operator=(const AbsOptionsBuilder &);
  flatbuffers::Offset<AbsOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AbsOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AbsOptions> CreateAbsOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalAndOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalAndOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndOptionsBuilder &operator=(const LogicalAndOptionsBuilder &);
  flatbuffers::Offset<LogicalAndOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAndOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAndOptions> CreateLogicalAndOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNotOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalNotOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotOptionsBuilder &operator=(const LogicalNotOptionsBuilder &);
  flatbuffers::Offset<LogicalNotOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNotOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNotOptions> CreateLogicalNotOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct UnpackOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct UnpackOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(UnpackOptions::VT_AXIS, axis, 0);
  }
  explicit UnpackOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnpackOptionsBuilder &operator=(const UnpackOptionsBuilder &);
  flatbuffers::Offset<UnpackOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnpackOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnpackOptions> CreateUnpackOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnpackOptionsBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

struct FloorDivOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorDivOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivOptionsBuilder &operator=(const FloorDivOptionsBuilder &);
  flatbuffers::Offset<FloorDivOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDivOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDivOptions> CreateFloorDivOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquareOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquareOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareOptionsBuilder &operator=(const SquareOptionsBuilder &);
  flatbuffers::Offset<SquareOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquareOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquareOptions> CreateSquareOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ZerosLikeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ZerosLikeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeOptionsBuilder &operator=(const ZerosLikeOptionsBuilder &);
  flatbuffers::Offset<ZerosLikeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLikeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLikeOptions> CreateZerosLikeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FillOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FillOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FillOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillOptionsBuilder &operator=(const FillOptionsBuilder &);
  flatbuffers::Offset<FillOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FillOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FillOptions> CreateFillOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FillOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorModOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorModOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModOptionsBuilder &operator=(const FloorModOptionsBuilder &);
  flatbuffers::Offset<FloorModOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorModOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorModOptions> CreateFloorModOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RangeOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RangeOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RangeOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeOptionsBuilder &operator=(const RangeOptionsBuilder &);
  flatbuffers::Offset<RangeOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RangeOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<RangeOptions> CreateRangeOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RangeOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LeakyReluOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct LeakyReluOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LeakyReluOptions::VT_ALPHA, alpha, 0.0f);
  }
  explicit LeakyReluOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReluOptionsBuilder &operator=(const LeakyReluOptionsBuilder &);
  flatbuffers::Offset<LeakyReluOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReluOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReluOptions> CreateLeakyReluOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0f) {
  LeakyReluOptionsBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct SquaredDifferenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquaredDifferenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceOptionsBuilder &operator=(const SquaredDifferenceOptionsBuilder &);
  flatbuffers::Offset<SquaredDifferenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifferenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifferenceOptions> CreateSquaredDifferenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MirrorPadOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MODE = 4
  };
  MirrorPadMode mode() const {
    return static_cast<MirrorPadMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct MirrorPadOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(MirrorPadMode mode) {
    fbb_.AddElement<int8_t>(MirrorPadOptions::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit MirrorPadOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MirrorPadOptionsBuilder &operator=(const MirrorPadOptionsBuilder &);
  flatbuffers::Offset<MirrorPadOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MirrorPadOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<MirrorPadOptions> CreateMirrorPadOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    MirrorPadMode mode = MirrorPadMode_REFLECT) {
  MirrorPadOptionsBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct UniqueOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_IDX_OUT_TYPE = 4
  };
  TensorType idx_out_type() const {
    return static_cast<TensorType>(GetField<int8_t>(VT_IDX_OUT_TYPE, 2));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_IDX_OUT_TYPE) &&
           verifier.EndTable();
  }
};

struct UniqueOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_idx_out_type(TensorType idx_out_type) {
    fbb_.AddElement<int8_t>(UniqueOptions::VT_IDX_OUT_TYPE, static_cast<int8_t>(idx_out_type), 2);
  }
  explicit UniqueOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueOptionsBuilder &operator=(const UniqueOptionsBuilder &);
  flatbuffers::Offset<UniqueOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UniqueOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<UniqueOptions> CreateUniqueOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    TensorType idx_out_type = TensorType_INT32) {
  UniqueOptionsBuilder builder_(_fbb);
  builder_.add_idx_out_type(idx_out_type);
  return builder_.Finish();
}

struct ReverseV2Options FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReverseV2OptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReverseV2OptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseV2OptionsBuilder &operator=(const ReverseV2OptionsBuilder &);
  flatbuffers::Offset<ReverseV2Options> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseV2Options>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseV2Options> CreateReverseV2Options(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReverseV2OptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddNOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddNOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddNOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNOptionsBuilder &operator=(const AddNOptionsBuilder &);
  flatbuffers::Offset<AddNOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddNOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddNOptions> CreateAddNOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddNOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GatherNdOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GatherNdOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GatherNdOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdOptionsBuilder &operator=(const GatherNdOptionsBuilder &);
  flatbuffers::Offset<GatherNdOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNdOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNdOptions> CreateGatherNdOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GatherNdOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct WhereOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct WhereOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit WhereOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereOptionsBuilder &operator=(const WhereOptionsBuilder &);
  flatbuffers::Offset<WhereOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<WhereOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<WhereOptions> CreateWhereOptions(
    flatbuffers::FlatBufferBuilder &_fbb) {
  WhereOptionsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ReverseSequenceOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SEQ_DIM = 4,
    VT_BATCH_DIM = 6
  };
  int32_t seq_dim() const {
    return GetField<int32_t>(VT_SEQ_DIM, 0);
  }
  int32_t batch_dim() const {
    return GetField<int32_t>(VT_BATCH_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQ_DIM) &&
           VerifyField<int32_t>(verifier, VT_BATCH_DIM) &&
           verifier.EndTable();
  }
};

struct ReverseSequenceOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seq_dim(int32_t seq_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_SEQ_DIM, seq_dim, 0);
  }
  void add_batch_dim(int32_t batch_dim) {
    fbb_.AddElement<int32_t>(ReverseSequenceOptions::VT_BATCH_DIM, batch_dim, 0);
  }
  explicit ReverseSequenceOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceOptionsBuilder &operator=(const ReverseSequenceOptionsBuilder &);
  flatbuffers::Offset<ReverseSequenceOptions> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequenceOptions>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequenceOptions> CreateReverseSequenceOptions(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seq_dim = 0,
    int32_t batch_dim = 0) {
  ReverseSequenceOptionsBuilder builder_(_fbb);
  builder_.add_batch_dim(batch_dim);
  builder_.add_seq_dim(seq_dim);
  return builder_.Finish();
}

struct OperatorCode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_BUILTIN_CODE = 4,
    VT_CUSTOM_CODE = 6,
    VT_VERSION = 8
  };
  BuiltinOperator builtin_code() const {
    return static_cast<BuiltinOperator>(GetField<int8_t>(VT_BUILTIN_CODE, 0));
  }
  const flatbuffers::String *custom_code() const {
    return GetPointer<const flatbuffers::String *>(VT_CUSTOM_CODE);
  }
  int32_t version() const {
    return GetField<int32_t>(VT_VERSION, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_BUILTIN_CODE) &&
           VerifyOffset(verifier, VT_CUSTOM_CODE) &&
           verifier.VerifyString(custom_code()) &&
           VerifyField<int32_t>(verifier, VT_VERSION) &&
           verifier.EndTable();
  }
};

struct OperatorCodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_builtin_code(BuiltinOperator builtin_code) {
    fbb_.AddElement<int8_t>(OperatorCode::VT_BUILTIN_CODE, static_cast<int8_t>(builtin_code), 0);
  }
  void add_custom_code(flatbuffers::Offset<flatbuffers::String> custom_code) {
    fbb_.AddOffset(OperatorCode::VT_CUSTOM_CODE, custom_code);
  }
  void add_version(int32_t version) {
    fbb_.AddElement<int32_t>(OperatorCode::VT_VERSION, version, 1);
  }
  explicit OperatorCodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorCodeBuilder &operator=(const OperatorCodeBuilder &);
  flatbuffers::Offset<OperatorCode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OperatorCode>(end);
    return o;
  }
};

inline flatbuffers::Offset<OperatorCode> CreateOperatorCode(
    flatbuffers::FlatBufferBuilder &_fbb,
    BuiltinOperator builtin_code = BuiltinOperator_ADD,
    flatbuffers::Offset<flatbuffers::String> custom_code = 0,
    int32_t version = 1) {
  OperatorCodeBuilder builder_(_fbb);
  builder_.add_version(version);
  builder_.add_custom_code(custom_code);
  builder_.add_builtin_code(builtin_code);
  return builder_.Finish();
}

inline flatbuffers::Offset<OperatorCode> CreateOperatorCodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    BuiltinOperator builtin_code = BuiltinOperator_ADD,
    const char *custom_code = nullptr,
    int32_t version = 1) {
  return tflite::CreateOperatorCode(
      _fbb,
      builtin_code,
      custom_code ? _fbb.CreateString(custom_code) : 0,
      version);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_OPCODE_INDEX = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_BUILTIN_OPTIONS_TYPE = 10,
    VT_BUILTIN_OPTIONS = 12,
    VT_CUSTOM_OPTIONS = 14,
    VT_CUSTOM_OPTIONS_FORMAT = 16,
    VT_MUTATING_VARIABLE_INPUTS = 18
  };
  uint32_t opcode_index() const {
    return GetField<uint32_t>(VT_OPCODE_INDEX, 0);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  BuiltinOptions builtin_options_type() const {
    return static_cast<BuiltinOptions>(GetField<uint8_t>(VT_BUILTIN_OPTIONS_TYPE, 0));
  }
  const void *builtin_options() const {
    return GetPointer<const void *>(VT_BUILTIN_OPTIONS);
  }
  template<typename T> const T *builtin_options_as() const;
  const Conv2DOptions *builtin_options_as_Conv2DOptions() const {
    return builtin_options_type() == BuiltinOptions_Conv2DOptions ? static_cast<const Conv2DOptions *>(builtin_options()) : nullptr;
  }
  const DepthwiseConv2DOptions *builtin_options_as_DepthwiseConv2DOptions() const {
    return builtin_options_type() == BuiltinOptions_DepthwiseConv2DOptions ? static_cast<const DepthwiseConv2DOptions *>(builtin_options()) : nullptr;
  }
  const ConcatEmbeddingsOptions *builtin_options_as_ConcatEmbeddingsOptions() const {
    return builtin_options_type() == BuiltinOptions_ConcatEmbeddingsOptions ? static_cast<const ConcatEmbeddingsOptions *>(builtin_options()) : nullptr;
  }
  const LSHProjectionOptions *builtin_options_as_LSHProjectionOptions() const {
    return builtin_options_type() == BuiltinOptions_LSHProjectionOptions ? static_cast<const LSHProjectionOptions *>(builtin_options()) : nullptr;
  }
  const Pool2DOptions *builtin_options_as_Pool2DOptions() const {
    return builtin_options_type() == BuiltinOptions_Pool2DOptions ? static_cast<const Pool2DOptions *>(builtin_options()) : nullptr;
  }
  const SVDFOptions *builtin_options_as_SVDFOptions() const {
    return builtin_options_type() == BuiltinOptions_SVDFOptions ? static_cast<const SVDFOptions *>(builtin_options()) : nullptr;
  }
  const RNNOptions *builtin_options_as_RNNOptions() const {
    return builtin_options_type() == BuiltinOptions_RNNOptions ? static_cast<const RNNOptions *>(builtin_options()) : nullptr;
  }
  const FullyConnectedOptions *builtin_options_as_FullyConnectedOptions() const {
    return builtin_options_type() == BuiltinOptions_FullyConnectedOptions ? static_cast<const FullyConnectedOptions *>(builtin_options()) : nullptr;
  }
  const SoftmaxOptions *builtin_options_as_SoftmaxOptions() const {
    return builtin_options_type() == BuiltinOptions_SoftmaxOptions ? static_cast<const SoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const ConcatenationOptions *builtin_options_as_ConcatenationOptions() const {
    return builtin_options_type() == BuiltinOptions_ConcatenationOptions ? static_cast<const ConcatenationOptions *>(builtin_options()) : nullptr;
  }
  const AddOptions *builtin_options_as_AddOptions() const {
    return builtin_options_type() == BuiltinOptions_AddOptions ? static_cast<const AddOptions *>(builtin_options()) : nullptr;
  }
  const L2NormOptions *builtin_options_as_L2NormOptions() const {
    return builtin_options_type() == BuiltinOptions_L2NormOptions ? static_cast<const L2NormOptions *>(builtin_options()) : nullptr;
  }
  const LocalResponseNormalizationOptions *builtin_options_as_LocalResponseNormalizationOptions() const {
    return builtin_options_type() == BuiltinOptions_LocalResponseNormalizationOptions ? static_cast<const LocalResponseNormalizationOptions *>(builtin_options()) : nullptr;
  }
  const LSTMOptions *builtin_options_as_LSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_LSTMOptions ? static_cast<const LSTMOptions *>(builtin_options()) : nullptr;
  }
  const ResizeBilinearOptions *builtin_options_as_ResizeBilinearOptions() const {
    return builtin_options_type() == BuiltinOptions_ResizeBilinearOptions ? static_cast<const ResizeBilinearOptions *>(builtin_options()) : nullptr;
  }
  const CallOptions *builtin_options_as_CallOptions() const {
    return builtin_options_type() == BuiltinOptions_CallOptions ? static_cast<const CallOptions *>(builtin_options()) : nullptr;
  }
  const ReshapeOptions *builtin_options_as_ReshapeOptions() const {
    return builtin_options_type() == BuiltinOptions_ReshapeOptions ? static_cast<const ReshapeOptions *>(builtin_options()) : nullptr;
  }
  const SkipGramOptions *builtin_options_as_SkipGramOptions() const {
    return builtin_options_type() == BuiltinOptions_SkipGramOptions ? static_cast<const SkipGramOptions *>(builtin_options()) : nullptr;
  }
  const SpaceToDepthOptions *builtin_options_as_SpaceToDepthOptions() const {
    return builtin_options_type() == BuiltinOptions_SpaceToDepthOptions ? static_cast<const SpaceToDepthOptions *>(builtin_options()) : nullptr;
  }
  const EmbeddingLookupSparseOptions *builtin_options_as_EmbeddingLookupSparseOptions() const {
    return builtin_options_type() == BuiltinOptions_EmbeddingLookupSparseOptions ? static_cast<const EmbeddingLookupSparseOptions *>(builtin_options()) : nullptr;
  }
  const MulOptions *builtin_options_as_MulOptions() const {
    return builtin_options_type() == BuiltinOptions_MulOptions ? static_cast<const MulOptions *>(builtin_options()) : nullptr;
  }
  const PadOptions *builtin_options_as_PadOptions() const {
    return builtin_options_type() == BuiltinOptions_PadOptions ? static_cast<const PadOptions *>(builtin_options()) : nullptr;
  }
  const GatherOptions *builtin_options_as_GatherOptions() const {
    return builtin_options_type() == BuiltinOptions_GatherOptions ? static_cast<const GatherOptions *>(builtin_options()) : nullptr;
  }
  const BatchToSpaceNDOptions *builtin_options_as_BatchToSpaceNDOptions() const {
    return builtin_options_type() == BuiltinOptions_BatchToSpaceNDOptions ? static_cast<const BatchToSpaceNDOptions *>(builtin_options()) : nullptr;
  }
  const SpaceToBatchNDOptions *builtin_options_as_SpaceToBatchNDOptions() const {
    return builtin_options_type() == BuiltinOptions_SpaceToBatchNDOptions ? static_cast<const SpaceToBatchNDOptions *>(builtin_options()) : nullptr;
  }
  const TransposeOptions *builtin_options_as_TransposeOptions() const {
    return builtin_options_type() == BuiltinOptions_TransposeOptions ? static_cast<const TransposeOptions *>(builtin_options()) : nullptr;
  }
  const ReducerOptions *builtin_options_as_ReducerOptions() const {
    return builtin_options_type() == BuiltinOptions_ReducerOptions ? static_cast<const ReducerOptions *>(builtin_options()) : nullptr;
  }
  const SubOptions *builtin_options_as_SubOptions() const {
    return builtin_options_type() == BuiltinOptions_SubOptions ? static_cast<const SubOptions *>(builtin_options()) : nullptr;
  }
  const DivOptions *builtin_options_as_DivOptions() const {
    return builtin_options_type() == BuiltinOptions_DivOptions ? static_cast<const DivOptions *>(builtin_options()) : nullptr;
  }
  const SqueezeOptions *builtin_options_as_SqueezeOptions() const {
    return builtin_options_type() == BuiltinOptions_SqueezeOptions ? static_cast<const SqueezeOptions *>(builtin_options()) : nullptr;
  }
  const SequenceRNNOptions *builtin_options_as_SequenceRNNOptions() const {
    return builtin_options_type() == BuiltinOptions_SequenceRNNOptions ? static_cast<const SequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const StridedSliceOptions *builtin_options_as_StridedSliceOptions() const {
    return builtin_options_type() == BuiltinOptions_StridedSliceOptions ? static_cast<const StridedSliceOptions *>(builtin_options()) : nullptr;
  }
  const ExpOptions *builtin_options_as_ExpOptions() const {
    return builtin_options_type() == BuiltinOptions_ExpOptions ? static_cast<const ExpOptions *>(builtin_options()) : nullptr;
  }
  const TopKV2Options *builtin_options_as_TopKV2Options() const {
    return builtin_options_type() == BuiltinOptions_TopKV2Options ? static_cast<const TopKV2Options *>(builtin_options()) : nullptr;
  }
  const SplitOptions *builtin_options_as_SplitOptions() const {
    return builtin_options_type() == BuiltinOptions_SplitOptions ? static_cast<const SplitOptions *>(builtin_options()) : nullptr;
  }
  const LogSoftmaxOptions *builtin_options_as_LogSoftmaxOptions() const {
    return builtin_options_type() == BuiltinOptions_LogSoftmaxOptions ? static_cast<const LogSoftmaxOptions *>(builtin_options()) : nullptr;
  }
  const CastOptions *builtin_options_as_CastOptions() const {
    return builtin_options_type() == BuiltinOptions_CastOptions ? static_cast<const CastOptions *>(builtin_options()) : nullptr;
  }
  const DequantizeOptions *builtin_options_as_DequantizeOptions() const {
    return builtin_options_type() == BuiltinOptions_DequantizeOptions ? static_cast<const DequantizeOptions *>(builtin_options()) : nullptr;
  }
  const MaximumMinimumOptions *builtin_options_as_MaximumMinimumOptions() const {
    return builtin_options_type() == BuiltinOptions_MaximumMinimumOptions ? static_cast<const MaximumMinimumOptions *>(builtin_options()) : nullptr;
  }
  const ArgMaxOptions *builtin_options_as_ArgMaxOptions() const {
    return builtin_options_type() == BuiltinOptions_ArgMaxOptions ? static_cast<const ArgMaxOptions *>(builtin_options()) : nullptr;
  }
  const LessOptions *builtin_options_as_LessOptions() const {
    return builtin_options_type() == BuiltinOptions_LessOptions ? static_cast<const LessOptions *>(builtin_options()) : nullptr;
  }
  const NegOptions *builtin_options_as_NegOptions() const {
    return builtin_options_type() == BuiltinOptions_NegOptions ? static_cast<const NegOptions *>(builtin_options()) : nullptr;
  }
  const PadV2Options *builtin_options_as_PadV2Options() const {
    return builtin_options_type() == BuiltinOptions_PadV2Options ? static_cast<const PadV2Options *>(builtin_options()) : nullptr;
  }
  const GreaterOptions *builtin_options_as_GreaterOptions() const {
    return builtin_options_type() == BuiltinOptions_GreaterOptions ? static_cast<const GreaterOptions *>(builtin_options()) : nullptr;
  }
  const GreaterEqualOptions *builtin_options_as_GreaterEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_GreaterEqualOptions ? static_cast<const GreaterEqualOptions *>(builtin_options()) : nullptr;
  }
  const LessEqualOptions *builtin_options_as_LessEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_LessEqualOptions ? static_cast<const LessEqualOptions *>(builtin_options()) : nullptr;
  }
  const SelectOptions *builtin_options_as_SelectOptions() const {
    return builtin_options_type() == BuiltinOptions_SelectOptions ? static_cast<const SelectOptions *>(builtin_options()) : nullptr;
  }
  const SliceOptions *builtin_options_as_SliceOptions() const {
    return builtin_options_type() == BuiltinOptions_SliceOptions ? static_cast<const SliceOptions *>(builtin_options()) : nullptr;
  }
  const TransposeConvOptions *builtin_options_as_TransposeConvOptions() const {
    return builtin_options_type() == BuiltinOptions_TransposeConvOptions ? static_cast<const TransposeConvOptions *>(builtin_options()) : nullptr;
  }
  const SparseToDenseOptions *builtin_options_as_SparseToDenseOptions() const {
    return builtin_options_type() == BuiltinOptions_SparseToDenseOptions ? static_cast<const SparseToDenseOptions *>(builtin_options()) : nullptr;
  }
  const TileOptions *builtin_options_as_TileOptions() const {
    return builtin_options_type() == BuiltinOptions_TileOptions ? static_cast<const TileOptions *>(builtin_options()) : nullptr;
  }
  const ExpandDimsOptions *builtin_options_as_ExpandDimsOptions() const {
    return builtin_options_type() == BuiltinOptions_ExpandDimsOptions ? static_cast<const ExpandDimsOptions *>(builtin_options()) : nullptr;
  }
  const EqualOptions *builtin_options_as_EqualOptions() const {
    return builtin_options_type() == BuiltinOptions_EqualOptions ? static_cast<const EqualOptions *>(builtin_options()) : nullptr;
  }
  const NotEqualOptions *builtin_options_as_NotEqualOptions() const {
    return builtin_options_type() == BuiltinOptions_NotEqualOptions ? static_cast<const NotEqualOptions *>(builtin_options()) : nullptr;
  }
  const ShapeOptions *builtin_options_as_ShapeOptions() const {
    return builtin_options_type() == BuiltinOptions_ShapeOptions ? static_cast<const ShapeOptions *>(builtin_options()) : nullptr;
  }
  const PowOptions *builtin_options_as_PowOptions() const {
    return builtin_options_type() == BuiltinOptions_PowOptions ? static_cast<const PowOptions *>(builtin_options()) : nullptr;
  }
  const ArgMinOptions *builtin_options_as_ArgMinOptions() const {
    return builtin_options_type() == BuiltinOptions_ArgMinOptions ? static_cast<const ArgMinOptions *>(builtin_options()) : nullptr;
  }
  const FakeQuantOptions *builtin_options_as_FakeQuantOptions() const {
    return builtin_options_type() == BuiltinOptions_FakeQuantOptions ? static_cast<const FakeQuantOptions *>(builtin_options()) : nullptr;
  }
  const PackOptions *builtin_options_as_PackOptions() const {
    return builtin_options_type() == BuiltinOptions_PackOptions ? static_cast<const PackOptions *>(builtin_options()) : nullptr;
  }
  const LogicalOrOptions *builtin_options_as_LogicalOrOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalOrOptions ? static_cast<const LogicalOrOptions *>(builtin_options()) : nullptr;
  }
  const OneHotOptions *builtin_options_as_OneHotOptions() const {
    return builtin_options_type() == BuiltinOptions_OneHotOptions ? static_cast<const OneHotOptions *>(builtin_options()) : nullptr;
  }
  const LogicalAndOptions *builtin_options_as_LogicalAndOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalAndOptions ? static_cast<const LogicalAndOptions *>(builtin_options()) : nullptr;
  }
  const LogicalNotOptions *builtin_options_as_LogicalNotOptions() const {
    return builtin_options_type() == BuiltinOptions_LogicalNotOptions ? static_cast<const LogicalNotOptions *>(builtin_options()) : nullptr;
  }
  const UnpackOptions *builtin_options_as_UnpackOptions() const {
    return builtin_options_type() == BuiltinOptions_UnpackOptions ? static_cast<const UnpackOptions *>(builtin_options()) : nullptr;
  }
  const FloorDivOptions *builtin_options_as_FloorDivOptions() const {
    return builtin_options_type() == BuiltinOptions_FloorDivOptions ? static_cast<const FloorDivOptions *>(builtin_options()) : nullptr;
  }
  const SquareOptions *builtin_options_as_SquareOptions() const {
    return builtin_options_type() == BuiltinOptions_SquareOptions ? static_cast<const SquareOptions *>(builtin_options()) : nullptr;
  }
  const ZerosLikeOptions *builtin_options_as_ZerosLikeOptions() const {
    return builtin_options_type() == BuiltinOptions_ZerosLikeOptions ? static_cast<const ZerosLikeOptions *>(builtin_options()) : nullptr;
  }
  const FillOptions *builtin_options_as_FillOptions() const {
    return builtin_options_type() == BuiltinOptions_FillOptions ? static_cast<const FillOptions *>(builtin_options()) : nullptr;
  }
  const BidirectionalSequenceLSTMOptions *builtin_options_as_BidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_BidirectionalSequenceLSTMOptions ? static_cast<const BidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const BidirectionalSequenceRNNOptions *builtin_options_as_BidirectionalSequenceRNNOptions() const {
    return builtin_options_type() == BuiltinOptions_BidirectionalSequenceRNNOptions ? static_cast<const BidirectionalSequenceRNNOptions *>(builtin_options()) : nullptr;
  }
  const UnidirectionalSequenceLSTMOptions *builtin_options_as_UnidirectionalSequenceLSTMOptions() const {
    return builtin_options_type() == BuiltinOptions_UnidirectionalSequenceLSTMOptions ? static_cast<const UnidirectionalSequenceLSTMOptions *>(builtin_options()) : nullptr;
  }
  const FloorModOptions *builtin_options_as_FloorModOptions() const {
    return builtin_options_type() == BuiltinOptions_FloorModOptions ? static_cast<const FloorModOptions *>(builtin_options()) : nullptr;
  }
  const RangeOptions *builtin_options_as_RangeOptions() const {
    return builtin_options_type() == BuiltinOptions_RangeOptions ? static_cast<const RangeOptions *>(builtin_options()) : nullptr;
  }
  const ResizeNearestNeighborOptions *builtin_options_as_ResizeNearestNeighborOptions() const {
    return builtin_options_type() == BuiltinOptions_ResizeNearestNeighborOptions ? static_cast<const ResizeNearestNeighborOptions *>(builtin_options()) : nullptr;
  }
  const LeakyReluOptions *builtin_options_as_LeakyReluOptions() const {
    return builtin_options_type() == BuiltinOptions_LeakyReluOptions ? static_cast<const LeakyReluOptions *>(builtin_options()) : nullptr;
  }
  const SquaredDifferenceOptions *builtin_options_as_SquaredDifferenceOptions() const {
    return builtin_options_type() == BuiltinOptions_SquaredDifferenceOptions ? static_cast<const SquaredDifferenceOptions *>(builtin_options()) : nullptr;
  }
  const MirrorPadOptions *builtin_options_as_MirrorPadOptions() const {
    return builtin_options_type() == BuiltinOptions_MirrorPadOptions ? static_cast<const MirrorPadOptions *>(builtin_options()) : nullptr;
  }
  const AbsOptions *builtin_options_as_AbsOptions() const {
    return builtin_options_type() == BuiltinOptions_AbsOptions ? static_cast<const AbsOptions *>(builtin_options()) : nullptr;
  }
  const SplitVOptions *builtin_options_as_SplitVOptions() const {
    return builtin_options_type() == BuiltinOptions_SplitVOptions ? static_cast<const SplitVOptions *>(builtin_options()) : nullptr;
  }
  const UniqueOptions *builtin_options_as_UniqueOptions() const {
    return builtin_options_type() == BuiltinOptions_UniqueOptions ? static_cast<const UniqueOptions *>(builtin_options()) : nullptr;
  }
  const ReverseV2Options *builtin_options_as_ReverseV2Options() const {
    return builtin_options_type() == BuiltinOptions_ReverseV2Options ? static_cast<const ReverseV2Options *>(builtin_options()) : nullptr;
  }
  const AddNOptions *builtin_options_as_AddNOptions() const {
    return builtin_options_type() == BuiltinOptions_AddNOptions ? static_cast<const AddNOptions *>(builtin_options()) : nullptr;
  }
  const GatherNdOptions *builtin_options_as_GatherNdOptions() const {
    return builtin_options_type() == BuiltinOptions_GatherNdOptions ? static_cast<const GatherNdOptions *>(builtin_options()) : nullptr;
  }
  const CosOptions *builtin_options_as_CosOptions() const {
    return builtin_options_type() == BuiltinOptions_CosOptions ? static_cast<const CosOptions *>(builtin_options()) : nullptr;
  }
  const WhereOptions *builtin_options_as_WhereOptions() const {
    return builtin_options_type() == BuiltinOptions_WhereOptions ? static_cast<const WhereOptions *>(builtin_options()) : nullptr;
  }
  const RankOptions *builtin_options_as_RankOptions() const {
    return builtin_options_type() == BuiltinOptions_RankOptions ? static_cast<const RankOptions *>(builtin_options()) : nullptr;
  }
  const ReverseSequenceOptions *builtin_options_as_ReverseSequenceOptions() const {
    return builtin_options_type() == BuiltinOptions_ReverseSequenceOptions ? static_cast<const ReverseSequenceOptions *>(builtin_options()) : nullptr;
  }
  const flatbuffers::Vector<uint8_t> *custom_options() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM_OPTIONS);
  }
  CustomOptionsFormat custom_options_format() const {
    return static_cast<CustomOptionsFormat>(GetField<int8_t>(VT_CUSTOM_OPTIONS_FORMAT, 0));
  }
  const flatbuffers::Vector<uint8_t> *mutating_variable_inputs() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_MUTATING_VARIABLE_INPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_OPCODE_INDEX) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyField<uint8_t>(verifier, VT_BUILTIN_OPTIONS_TYPE) &&
           VerifyOffset(verifier, VT_BUILTIN_OPTIONS) &&
           VerifyBuiltinOptions(verifier, builtin_options(), builtin_options_type()) &&
           VerifyOffset(verifier, VT_CUSTOM_OPTIONS) &&
           verifier.VerifyVector(custom_options()) &&
           VerifyField<int8_t>(verifier, VT_CUSTOM_OPTIONS_FORMAT) &&
           VerifyOffset(verifier, VT_MUTATING_VARIABLE_INPUTS) &&
           verifier.VerifyVector(mutating_variable_inputs()) &&
           verifier.EndTable();
  }
};

template<> inline const Conv2DOptions *Operator::builtin_options_as<Conv2DOptions>() const {
  return builtin_options_as_Conv2DOptions();
}

template<> inline const DepthwiseConv2DOptions *Operator::builtin_options_as<DepthwiseConv2DOptions>() const {
  return builtin_options_as_DepthwiseConv2DOptions();
}

template<> inline const ConcatEmbeddingsOptions *Operator::builtin_options_as<ConcatEmbeddingsOptions>() const {
  return builtin_options_as_ConcatEmbeddingsOptions();
}

template<> inline const LSHProjectionOptions *Operator::builtin_options_as<LSHProjectionOptions>() const {
  return builtin_options_as_LSHProjectionOptions();
}

template<> inline const Pool2DOptions *Operator::builtin_options_as<Pool2DOptions>() const {
  return builtin_options_as_Pool2DOptions();
}

template<> inline const SVDFOptions *Operator::builtin_options_as<SVDFOptions>() const {
  return builtin_options_as_SVDFOptions();
}

template<> inline const RNNOptions *Operator::builtin_options_as<RNNOptions>() const {
  return builtin_options_as_RNNOptions();
}

template<> inline const FullyConnectedOptions *Operator::builtin_options_as<FullyConnectedOptions>() const {
  return builtin_options_as_FullyConnectedOptions();
}

template<> inline const SoftmaxOptions *Operator::builtin_options_as<SoftmaxOptions>() const {
  return builtin_options_as_SoftmaxOptions();
}

template<> inline const ConcatenationOptions *Operator::builtin_options_as<ConcatenationOptions>() const {
  return builtin_options_as_ConcatenationOptions();
}

template<> inline const AddOptions *Operator::builtin_options_as<AddOptions>() const {
  return builtin_options_as_AddOptions();
}

template<> inline const L2NormOptions *Operator::builtin_options_as<L2NormOptions>() const {
  return builtin_options_as_L2NormOptions();
}

template<> inline const LocalResponseNormalizationOptions *Operator::builtin_options_as<LocalResponseNormalizationOptions>() const {
  return builtin_options_as_LocalResponseNormalizationOptions();
}

template<> inline const LSTMOptions *Operator::builtin_options_as<LSTMOptions>() const {
  return builtin_options_as_LSTMOptions();
}

template<> inline const ResizeBilinearOptions *Operator::builtin_options_as<ResizeBilinearOptions>() const {
  return builtin_options_as_ResizeBilinearOptions();
}

template<> inline const CallOptions *Operator::builtin_options_as<CallOptions>() const {
  return builtin_options_as_CallOptions();
}

template<> inline const ReshapeOptions *Operator::builtin_options_as<ReshapeOptions>() const {
  return builtin_options_as_ReshapeOptions();
}

template<> inline const SkipGramOptions *Operator::builtin_options_as<SkipGramOptions>() const {
  return builtin_options_as_SkipGramOptions();
}

template<> inline const SpaceToDepthOptions *Operator::builtin_options_as<SpaceToDepthOptions>() const {
  return builtin_options_as_SpaceToDepthOptions();
}

template<> inline const EmbeddingLookupSparseOptions *Operator::builtin_options_as<EmbeddingLookupSparseOptions>() const {
  return builtin_options_as_EmbeddingLookupSparseOptions();
}

template<> inline const MulOptions *Operator::builtin_options_as<MulOptions>() const {
  return builtin_options_as_MulOptions();
}

template<> inline const PadOptions *Operator::builtin_options_as<PadOptions>() const {
  return builtin_options_as_PadOptions();
}

template<> inline const GatherOptions *Operator::builtin_options_as<GatherOptions>() const {
  return builtin_options_as_GatherOptions();
}

template<> inline const BatchToSpaceNDOptions *Operator::builtin_options_as<BatchToSpaceNDOptions>() const {
  return builtin_options_as_BatchToSpaceNDOptions();
}

template<> inline const SpaceToBatchNDOptions *Operator::builtin_options_as<SpaceToBatchNDOptions>() const {
  return builtin_options_as_SpaceToBatchNDOptions();
}

template<> inline const TransposeOptions *Operator::builtin_options_as<TransposeOptions>() const {
  return builtin_options_as_TransposeOptions();
}

template<> inline const ReducerOptions *Operator::builtin_options_as<ReducerOptions>() const {
  return builtin_options_as_ReducerOptions();
}

template<> inline const SubOptions *Operator::builtin_options_as<SubOptions>() const {
  return builtin_options_as_SubOptions();
}

template<> inline const DivOptions *Operator::builtin_options_as<DivOptions>() const {
  return builtin_options_as_DivOptions();
}

template<> inline const SqueezeOptions *Operator::builtin_options_as<SqueezeOptions>() const {
  return builtin_options_as_SqueezeOptions();
}

template<> inline const SequenceRNNOptions *Operator::builtin_options_as<SequenceRNNOptions>() const {
  return builtin_options_as_SequenceRNNOptions();
}

template<> inline const StridedSliceOptions *Operator::builtin_options_as<StridedSliceOptions>() const {
  return builtin_options_as_StridedSliceOptions();
}

template<> inline const ExpOptions *Operator::builtin_options_as<ExpOptions>() const {
  return builtin_options_as_ExpOptions();
}

template<> inline const TopKV2Options *Operator::builtin_options_as<TopKV2Options>() const {
  return builtin_options_as_TopKV2Options();
}

template<> inline const SplitOptions *Operator::builtin_options_as<SplitOptions>() const {
  return builtin_options_as_SplitOptions();
}

template<> inline const LogSoftmaxOptions *Operator::builtin_options_as<LogSoftmaxOptions>() const {
  return builtin_options_as_LogSoftmaxOptions();
}

template<> inline const CastOptions *Operator::builtin_options_as<CastOptions>() const {
  return builtin_options_as_CastOptions();
}

template<> inline const DequantizeOptions *Operator::builtin_options_as<DequantizeOptions>() const {
  return builtin_options_as_DequantizeOptions();
}

template<> inline const MaximumMinimumOptions *Operator::builtin_options_as<MaximumMinimumOptions>() const {
  return builtin_options_as_MaximumMinimumOptions();
}

template<> inline const ArgMaxOptions *Operator::builtin_options_as<ArgMaxOptions>() const {
  return builtin_options_as_ArgMaxOptions();
}

template<> inline const LessOptions *Operator::builtin_options_as<LessOptions>() const {
  return builtin_options_as_LessOptions();
}

template<> inline const NegOptions *Operator::builtin_options_as<NegOptions>() const {
  return builtin_options_as_NegOptions();
}

template<> inline const PadV2Options *Operator::builtin_options_as<PadV2Options>() const {
  return builtin_options_as_PadV2Options();
}

template<> inline const GreaterOptions *Operator::builtin_options_as<GreaterOptions>() const {
  return builtin_options_as_GreaterOptions();
}

template<> inline const GreaterEqualOptions *Operator::builtin_options_as<GreaterEqualOptions>() const {
  return builtin_options_as_GreaterEqualOptions();
}

template<> inline const LessEqualOptions *Operator::builtin_options_as<LessEqualOptions>() const {
  return builtin_options_as_LessEqualOptions();
}

template<> inline const SelectOptions *Operator::builtin_options_as<SelectOptions>() const {
  return builtin_options_as_SelectOptions();
}

template<> inline const SliceOptions *Operator::builtin_options_as<SliceOptions>() const {
  return builtin_options_as_SliceOptions();
}

template<> inline const TransposeConvOptions *Operator::builtin_options_as<TransposeConvOptions>() const {
  return builtin_options_as_TransposeConvOptions();
}

template<> inline const SparseToDenseOptions *Operator::builtin_options_as<SparseToDenseOptions>() const {
  return builtin_options_as_SparseToDenseOptions();
}

template<> inline const TileOptions *Operator::builtin_options_as<TileOptions>() const {
  return builtin_options_as_TileOptions();
}

template<> inline const ExpandDimsOptions *Operator::builtin_options_as<ExpandDimsOptions>() const {
  return builtin_options_as_ExpandDimsOptions();
}

template<> inline const EqualOptions *Operator::builtin_options_as<EqualOptions>() const {
  return builtin_options_as_EqualOptions();
}

template<> inline const NotEqualOptions *Operator::builtin_options_as<NotEqualOptions>() const {
  return builtin_options_as_NotEqualOptions();
}

template<> inline const ShapeOptions *Operator::builtin_options_as<ShapeOptions>() const {
  return builtin_options_as_ShapeOptions();
}

template<> inline const PowOptions *Operator::builtin_options_as<PowOptions>() const {
  return builtin_options_as_PowOptions();
}

template<> inline const ArgMinOptions *Operator::builtin_options_as<ArgMinOptions>() const {
  return builtin_options_as_ArgMinOptions();
}

template<> inline const FakeQuantOptions *Operator::builtin_options_as<FakeQuantOptions>() const {
  return builtin_options_as_FakeQuantOptions();
}

template<> inline const PackOptions *Operator::builtin_options_as<PackOptions>() const {
  return builtin_options_as_PackOptions();
}

template<> inline const LogicalOrOptions *Operator::builtin_options_as<LogicalOrOptions>() const {
  return builtin_options_as_LogicalOrOptions();
}

template<> inline const OneHotOptions *Operator::builtin_options_as<OneHotOptions>() const {
  return builtin_options_as_OneHotOptions();
}

template<> inline const LogicalAndOptions *Operator::builtin_options_as<LogicalAndOptions>() const {
  return builtin_options_as_LogicalAndOptions();
}

template<> inline const LogicalNotOptions *Operator::builtin_options_as<LogicalNotOptions>() const {
  return builtin_options_as_LogicalNotOptions();
}

template<> inline const UnpackOptions *Operator::builtin_options_as<UnpackOptions>() const {
  return builtin_options_as_UnpackOptions();
}

template<> inline const FloorDivOptions *Operator::builtin_options_as<FloorDivOptions>() const {
  return builtin_options_as_FloorDivOptions();
}

template<> inline const SquareOptions *Operator::builtin_options_as<SquareOptions>() const {
  return builtin_options_as_SquareOptions();
}

template<> inline const ZerosLikeOptions *Operator::builtin_options_as<ZerosLikeOptions>() const {
  return builtin_options_as_ZerosLikeOptions();
}

template<> inline const FillOptions *Operator::builtin_options_as<FillOptions>() const {
  return builtin_options_as_FillOptions();
}

template<> inline const BidirectionalSequenceLSTMOptions *Operator::builtin_options_as<BidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_BidirectionalSequenceLSTMOptions();
}

template<> inline const BidirectionalSequenceRNNOptions *Operator::builtin_options_as<BidirectionalSequenceRNNOptions>() const {
  return builtin_options_as_BidirectionalSequenceRNNOptions();
}

template<> inline const UnidirectionalSequenceLSTMOptions *Operator::builtin_options_as<UnidirectionalSequenceLSTMOptions>() const {
  return builtin_options_as_UnidirectionalSequenceLSTMOptions();
}

template<> inline const FloorModOptions *Operator::builtin_options_as<FloorModOptions>() const {
  return builtin_options_as_FloorModOptions();
}

template<> inline const RangeOptions *Operator::builtin_options_as<RangeOptions>() const {
  return builtin_options_as_RangeOptions();
}

template<> inline const ResizeNearestNeighborOptions *Operator::builtin_options_as<ResizeNearestNeighborOptions>() const {
  return builtin_options_as_ResizeNearestNeighborOptions();
}

template<> inline const LeakyReluOptions *Operator::builtin_options_as<LeakyReluOptions>() const {
  return builtin_options_as_LeakyReluOptions();
}

template<> inline const SquaredDifferenceOptions *Operator::builtin_options_as<SquaredDifferenceOptions>() const {
  return builtin_options_as_SquaredDifferenceOptions();
}

template<> inline const MirrorPadOptions *Operator::builtin_options_as<MirrorPadOptions>() const {
  return builtin_options_as_MirrorPadOptions();
}

template<> inline const AbsOptions *Operator::builtin_options_as<AbsOptions>() const {
  return builtin_options_as_AbsOptions();
}

template<> inline const SplitVOptions *Operator::builtin_options_as<SplitVOptions>() const {
  return builtin_options_as_SplitVOptions();
}

template<> inline const UniqueOptions *Operator::builtin_options_as<UniqueOptions>() const {
  return builtin_options_as_UniqueOptions();
}

template<> inline const ReverseV2Options *Operator::builtin_options_as<ReverseV2Options>() const {
  return builtin_options_as_ReverseV2Options();
}

template<> inline const AddNOptions *Operator::builtin_options_as<AddNOptions>() const {
  return builtin_options_as_AddNOptions();
}

template<> inline const GatherNdOptions *Operator::builtin_options_as<GatherNdOptions>() const {
  return builtin_options_as_GatherNdOptions();
}

template<> inline const CosOptions *Operator::builtin_options_as<CosOptions>() const {
  return builtin_options_as_CosOptions();
}

template<> inline const WhereOptions *Operator::builtin_options_as<WhereOptions>() const {
  return builtin_options_as_WhereOptions();
}

template<> inline const RankOptions *Operator::builtin_options_as<RankOptions>() const {
  return builtin_options_as_RankOptions();
}

template<> inline const ReverseSequenceOptions *Operator::builtin_options_as<ReverseSequenceOptions>() const {
  return builtin_options_as_ReverseSequenceOptions();
}

struct OperatorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_opcode_index(uint32_t opcode_index) {
    fbb_.AddElement<uint32_t>(Operator::VT_OPCODE_INDEX, opcode_index, 0);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_builtin_options_type(BuiltinOptions builtin_options_type) {
    fbb_.AddElement<uint8_t>(Operator::VT_BUILTIN_OPTIONS_TYPE, static_cast<uint8_t>(builtin_options_type), 0);
  }
  void add_builtin_options(flatbuffers::Offset<void> builtin_options) {
    fbb_.AddOffset(Operator::VT_BUILTIN_OPTIONS, builtin_options);
  }
  void add_custom_options(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options) {
    fbb_.AddOffset(Operator::VT_CUSTOM_OPTIONS, custom_options);
  }
  void add_custom_options_format(CustomOptionsFormat custom_options_format) {
    fbb_.AddElement<int8_t>(Operator::VT_CUSTOM_OPTIONS_FORMAT, static_cast<int8_t>(custom_options_format), 0);
  }
  void add_mutating_variable_inputs(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs) {
    fbb_.AddOffset(Operator::VT_MUTATING_VARIABLE_INPUTS, mutating_variable_inputs);
  }
  explicit OperatorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OperatorBuilder &operator=(const OperatorBuilder &);
  flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline flatbuffers::Offset<Operator> CreateOperator(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    BuiltinOptions builtin_options_type = BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom_options = 0,
    CustomOptionsFormat custom_options_format = CustomOptionsFormat_FLEXBUFFERS,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> mutating_variable_inputs = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_mutating_variable_inputs(mutating_variable_inputs);
  builder_.add_custom_options(custom_options);
  builder_.add_builtin_options(builtin_options);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_opcode_index(opcode_index);
  builder_.add_custom_options_format(custom_options_format);
  builder_.add_builtin_options_type(builtin_options_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Operator> CreateOperatorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t opcode_index = 0,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    BuiltinOptions builtin_options_type = BuiltinOptions_NONE,
    flatbuffers::Offset<void> builtin_options = 0,
    const std::vector<uint8_t> *custom_options = nullptr,
    CustomOptionsFormat custom_options_format = CustomOptionsFormat_FLEXBUFFERS,
    const std::vector<uint8_t> *mutating_variable_inputs = nullptr) {
  return tflite::CreateOperator(
      _fbb,
      opcode_index,
      inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0,
      outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0,
      builtin_options_type,
      builtin_options,
      custom_options ? _fbb.CreateVector<uint8_t>(*custom_options) : 0,
      custom_options_format,
      mutating_variable_inputs ? _fbb.CreateVector<uint8_t>(*mutating_variable_inputs) : 0);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TENSORS = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_OPERATORS = 10,
    VT_NAME = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Operator>> *operators() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Operator>> *>(VT_OPERATORS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_OPERATORS) &&
           verifier.VerifyVector(operators()) &&
           verifier.VerifyVectorOfTables(operators()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_operators(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Operator>>> operators) {
    fbb_.AddOffset(SubGraph::VT_OPERATORS, operators);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder &operator=(const SubGraphBuilder &);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Operator>>> operators = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_operators(operators);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_tensors(tensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<Tensor>> *tensors = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<Operator>> *operators = nullptr,
    const char *name = nullptr) {
  return tflite::CreateSubGraph(
      _fbb,
      tensors ? _fbb.CreateVector<flatbuffers::Offset<Tensor>>(*tensors) : 0,
      inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0,
      outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0,
      operators ? _fbb.CreateVector<flatbuffers::Offset<Operator>>(*operators) : 0,
      name ? _fbb.CreateString(name) : 0);
}

struct Buffer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_DATA = 4
  };
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct BufferBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Buffer::VT_DATA, data);
  }
  explicit BufferBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BufferBuilder &operator=(const BufferBuilder &);
  flatbuffers::Offset<Buffer> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Buffer>(end);
    return o;
  }
};

inline flatbuffers::Offset<Buffer> CreateBuffer(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0) {
  BufferBuilder builder_(_fbb);
  builder_.add_data(data);
  return builder_.Finish();
}

inline flatbuffers::Offset<Buffer> CreateBufferDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *data = nullptr) {
  return tflite::CreateBuffer(
      _fbb,
      data ? _fbb.CreateVector<uint8_t>(*data) : 0);
}

struct Model FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_OPERATOR_CODES = 6,
    VT_SUBGRAPHS = 8,
    VT_DESCRIPTION = 10,
    VT_BUFFERS = 12,
    VT_METADATA_BUFFER = 14
  };
  uint32_t version() const {
    return GetField<uint32_t>(VT_VERSION, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<OperatorCode>> *operator_codes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<OperatorCode>> *>(VT_OPERATOR_CODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *subgraphs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *>(VT_SUBGRAPHS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *buffers() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Buffer>> *>(VT_BUFFERS);
  }
  const flatbuffers::Vector<int32_t> *metadata_buffer() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_METADATA_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_OPERATOR_CODES) &&
           verifier.VerifyVector(operator_codes()) &&
           verifier.VerifyVectorOfTables(operator_codes()) &&
           VerifyOffset(verifier, VT_SUBGRAPHS) &&
           verifier.VerifyVector(subgraphs()) &&
           verifier.VerifyVectorOfTables(subgraphs()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_BUFFERS) &&
           verifier.VerifyVector(buffers()) &&
           verifier.VerifyVectorOfTables(buffers()) &&
           VerifyOffset(verifier, VT_METADATA_BUFFER) &&
           verifier.VerifyVector(metadata_buffer()) &&
           verifier.EndTable();
  }
};

struct ModelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(uint32_t version) {
    fbb_.AddElement<uint32_t>(Model::VT_VERSION, version, 0);
  }
  void add_operator_codes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OperatorCode>>> operator_codes) {
    fbb_.AddOffset(Model::VT_OPERATOR_CODES, operator_codes);
  }
  void add_subgraphs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subgraphs) {
    fbb_.AddOffset(Model::VT_SUBGRAPHS, subgraphs);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Model::VT_DESCRIPTION, description);
  }
  void add_buffers(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers) {
    fbb_.AddOffset(Model::VT_BUFFERS, buffers);
  }
  void add_metadata_buffer(flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer) {
    fbb_.AddOffset(Model::VT_METADATA_BUFFER, metadata_buffer);
  }
  explicit ModelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModelBuilder &operator=(const ModelBuilder &);
  flatbuffers::Offset<Model> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Model>(end);
    return o;
  }
};

inline flatbuffers::Offset<Model> CreateModel(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<OperatorCode>>> operator_codes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subgraphs = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Buffer>>> buffers = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> metadata_buffer = 0) {
  ModelBuilder builder_(_fbb);
  builder_.add_metadata_buffer(metadata_buffer);
  builder_.add_buffers(buffers);
  builder_.add_description(description);
  builder_.add_subgraphs(subgraphs);
  builder_.add_operator_codes(operator_codes);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<Model> CreateModelDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t version = 0,
    const std::vector<flatbuffers::Offset<OperatorCode>> *operator_codes = nullptr,
    const std::vector<flatbuffers::Offset<SubGraph>> *subgraphs = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<Buffer>> *buffers = nullptr,
    const std::vector<int32_t> *metadata_buffer = nullptr) {
  return tflite::CreateModel(
      _fbb,
      version,
      operator_codes ? _fbb.CreateVector<flatbuffers::Offset<OperatorCode>>(*operator_codes) : 0,
      subgraphs ? _fbb.CreateVector<flatbuffers::Offset<SubGraph>>(*subgraphs) : 0,
      description ? _fbb.CreateString(description) : 0,
      buffers ? _fbb.CreateVector<flatbuffers::Offset<Buffer>>(*buffers) : 0,
      metadata_buffer ? _fbb.CreateVector<int32_t>(*metadata_buffer) : 0);
}

inline bool VerifyQuantizationDetails(flatbuffers::Verifier &verifier, const void *obj, QuantizationDetails type) {
  switch (type) {
    case QuantizationDetails_NONE: {
      return true;
    }
    case QuantizationDetails_CustomQuantization: {
      auto ptr = reinterpret_cast<const CustomQuantization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyQuantizationDetailsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyQuantizationDetails(
        verifier,  values->Get(i), types->GetEnum<QuantizationDetails>(i))) {
      return false;
    }
  }
  return true;
}

inline bool VerifyBuiltinOptions(flatbuffers::Verifier &verifier, const void *obj, BuiltinOptions type) {
  switch (type) {
    case BuiltinOptions_NONE: {
      return true;
    }
    case BuiltinOptions_Conv2DOptions: {
      auto ptr = reinterpret_cast<const Conv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DepthwiseConv2DOptions: {
      auto ptr = reinterpret_cast<const DepthwiseConv2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatEmbeddingsOptions: {
      auto ptr = reinterpret_cast<const ConcatEmbeddingsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSHProjectionOptions: {
      auto ptr = reinterpret_cast<const LSHProjectionOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_Pool2DOptions: {
      auto ptr = reinterpret_cast<const Pool2DOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SVDFOptions: {
      auto ptr = reinterpret_cast<const SVDFOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RNNOptions: {
      auto ptr = reinterpret_cast<const RNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FullyConnectedOptions: {
      auto ptr = reinterpret_cast<const FullyConnectedOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SoftmaxOptions: {
      auto ptr = reinterpret_cast<const SoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ConcatenationOptions: {
      auto ptr = reinterpret_cast<const ConcatenationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddOptions: {
      auto ptr = reinterpret_cast<const AddOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_L2NormOptions: {
      auto ptr = reinterpret_cast<const L2NormOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LocalResponseNormalizationOptions: {
      auto ptr = reinterpret_cast<const LocalResponseNormalizationOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LSTMOptions: {
      auto ptr = reinterpret_cast<const LSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeBilinearOptions: {
      auto ptr = reinterpret_cast<const ResizeBilinearOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CallOptions: {
      auto ptr = reinterpret_cast<const CallOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReshapeOptions: {
      auto ptr = reinterpret_cast<const ReshapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SkipGramOptions: {
      auto ptr = reinterpret_cast<const SkipGramOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToDepthOptions: {
      auto ptr = reinterpret_cast<const SpaceToDepthOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EmbeddingLookupSparseOptions: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MulOptions: {
      auto ptr = reinterpret_cast<const MulOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadOptions: {
      auto ptr = reinterpret_cast<const PadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherOptions: {
      auto ptr = reinterpret_cast<const GatherOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BatchToSpaceNDOptions: {
      auto ptr = reinterpret_cast<const BatchToSpaceNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SpaceToBatchNDOptions: {
      auto ptr = reinterpret_cast<const SpaceToBatchNDOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeOptions: {
      auto ptr = reinterpret_cast<const TransposeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReducerOptions: {
      auto ptr = reinterpret_cast<const ReducerOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SubOptions: {
      auto ptr = reinterpret_cast<const SubOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DivOptions: {
      auto ptr = reinterpret_cast<const DivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SqueezeOptions: {
      auto ptr = reinterpret_cast<const SqueezeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SequenceRNNOptions: {
      auto ptr = reinterpret_cast<const SequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_StridedSliceOptions: {
      auto ptr = reinterpret_cast<const StridedSliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpOptions: {
      auto ptr = reinterpret_cast<const ExpOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TopKV2Options: {
      auto ptr = reinterpret_cast<const TopKV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitOptions: {
      auto ptr = reinterpret_cast<const SplitOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogSoftmaxOptions: {
      auto ptr = reinterpret_cast<const LogSoftmaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CastOptions: {
      auto ptr = reinterpret_cast<const CastOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_DequantizeOptions: {
      auto ptr = reinterpret_cast<const DequantizeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MaximumMinimumOptions: {
      auto ptr = reinterpret_cast<const MaximumMinimumOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMaxOptions: {
      auto ptr = reinterpret_cast<const ArgMaxOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessOptions: {
      auto ptr = reinterpret_cast<const LessOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NegOptions: {
      auto ptr = reinterpret_cast<const NegOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PadV2Options: {
      auto ptr = reinterpret_cast<const PadV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterOptions: {
      auto ptr = reinterpret_cast<const GreaterOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GreaterEqualOptions: {
      auto ptr = reinterpret_cast<const GreaterEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LessEqualOptions: {
      auto ptr = reinterpret_cast<const LessEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SelectOptions: {
      auto ptr = reinterpret_cast<const SelectOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SliceOptions: {
      auto ptr = reinterpret_cast<const SliceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TransposeConvOptions: {
      auto ptr = reinterpret_cast<const TransposeConvOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SparseToDenseOptions: {
      auto ptr = reinterpret_cast<const SparseToDenseOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_TileOptions: {
      auto ptr = reinterpret_cast<const TileOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ExpandDimsOptions: {
      auto ptr = reinterpret_cast<const ExpandDimsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_EqualOptions: {
      auto ptr = reinterpret_cast<const EqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_NotEqualOptions: {
      auto ptr = reinterpret_cast<const NotEqualOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ShapeOptions: {
      auto ptr = reinterpret_cast<const ShapeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PowOptions: {
      auto ptr = reinterpret_cast<const PowOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ArgMinOptions: {
      auto ptr = reinterpret_cast<const ArgMinOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FakeQuantOptions: {
      auto ptr = reinterpret_cast<const FakeQuantOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_PackOptions: {
      auto ptr = reinterpret_cast<const PackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalOrOptions: {
      auto ptr = reinterpret_cast<const LogicalOrOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_OneHotOptions: {
      auto ptr = reinterpret_cast<const OneHotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalAndOptions: {
      auto ptr = reinterpret_cast<const LogicalAndOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LogicalNotOptions: {
      auto ptr = reinterpret_cast<const LogicalNotOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnpackOptions: {
      auto ptr = reinterpret_cast<const UnpackOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorDivOptions: {
      auto ptr = reinterpret_cast<const FloorDivOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquareOptions: {
      auto ptr = reinterpret_cast<const SquareOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ZerosLikeOptions: {
      auto ptr = reinterpret_cast<const ZerosLikeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FillOptions: {
      auto ptr = reinterpret_cast<const FillOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_BidirectionalSequenceRNNOptions: {
      auto ptr = reinterpret_cast<const BidirectionalSequenceRNNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UnidirectionalSequenceLSTMOptions: {
      auto ptr = reinterpret_cast<const UnidirectionalSequenceLSTMOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_FloorModOptions: {
      auto ptr = reinterpret_cast<const FloorModOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RangeOptions: {
      auto ptr = reinterpret_cast<const RangeOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ResizeNearestNeighborOptions: {
      auto ptr = reinterpret_cast<const ResizeNearestNeighborOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_LeakyReluOptions: {
      auto ptr = reinterpret_cast<const LeakyReluOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SquaredDifferenceOptions: {
      auto ptr = reinterpret_cast<const SquaredDifferenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_MirrorPadOptions: {
      auto ptr = reinterpret_cast<const MirrorPadOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AbsOptions: {
      auto ptr = reinterpret_cast<const AbsOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_SplitVOptions: {
      auto ptr = reinterpret_cast<const SplitVOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_UniqueOptions: {
      auto ptr = reinterpret_cast<const UniqueOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseV2Options: {
      auto ptr = reinterpret_cast<const ReverseV2Options *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_AddNOptions: {
      auto ptr = reinterpret_cast<const AddNOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_GatherNdOptions: {
      auto ptr = reinterpret_cast<const GatherNdOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_CosOptions: {
      auto ptr = reinterpret_cast<const CosOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_WhereOptions: {
      auto ptr = reinterpret_cast<const WhereOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_RankOptions: {
      auto ptr = reinterpret_cast<const RankOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case BuiltinOptions_ReverseSequenceOptions: {
      auto ptr = reinterpret_cast<const ReverseSequenceOptions *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyBuiltinOptionsVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyBuiltinOptions(
        verifier,  values->Get(i), types->GetEnum<BuiltinOptions>(i))) {
      return false;
    }
  }
  return true;
}

inline const tflite::Model *GetModel(const void *buf) {
  return flatbuffers::GetRoot<tflite::Model>(buf);
}

inline const tflite::Model *GetSizePrefixedModel(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<tflite::Model>(buf);
}

inline const char *ModelIdentifier() {
  return "TFL3";
}

inline bool ModelBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ModelIdentifier());
}

inline bool VerifyModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<tflite::Model>(ModelIdentifier());
}

inline bool VerifySizePrefixedModelBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<tflite::Model>(ModelIdentifier());
}

inline const char *ModelExtension() {
  return "tflite";
}

inline void FinishModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.Finish(root, ModelIdentifier());
}

inline void FinishSizePrefixedModelBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<tflite::Model> root) {
  fbb.FinishSizePrefixed(root, ModelIdentifier());
}

}  // namespace tflite

#endif  // FLATBUFFERS_GENERATED_SCHEMA_TFLITE_H_
