// This file is generated by Nncase CPU module builder at @Html.Raw(DateTimeOffset.Now).
#include <cstdint>
#include <cstddef>
#include <cmath>
#include <cstring>
#include <span>

// compiler support
#if defined(_MSC_VER)
extern "C" {
enum ISA_AVAILABILITY
{
    __ISA_AVAILABLE_X86   = 0,
    __ISA_AVAILABLE_SSE2  = 1,
    __ISA_AVAILABLE_SSE42 = 2,
    __ISA_AVAILABLE_AVX   = 3,
    __ISA_AVAILABLE_ENFSTRG = 4,
    __ISA_AVAILABLE_AVX2 = 5,

    __ISA_AVAILABLE_ARMNT   = 0,   // minimum Win8 ARM support (but w/o NEON)
    __ISA_AVAILABLE_NEON    = 1,   // support for 128-bit NEON instructions
    __ISA_AVAILABLE_NEON_ARM64 = 2,// support for 128-bit NEON instructions for ARM64. The distinction between ARM32 and
                                   // ARM64 NEON is temporary. They may eventually be merged.
};

int _fltused = 0;
unsigned int __favor = 0;
unsigned int __isa_available = __ISA_AVAILABLE_AVX;
}
#endif

extern "C" {
    struct nncase_runtime_cpu_mt_t {
        float (*acoshf)(float v);
    };

    nncase_runtime_cpu_mt_t *g_cpu_mt;
}

namespace nncase::runtime::cpu {
    template<class T, class Shape, class Strides>
    class tensor_view;

    // data types
    template<size_t...Dims>
    struct fixed_dims_t {
        static constexpr size_t length() noexcept { return sizeof...(Dims) ? (Dims + ...) : 1; }
    };

    template<class T, class Shape>
    class tensor {
    public:
        static constexpr auto shape() noexcept { return Shape{}; }

        auto buffer() noexcept { return std::span(buffer_); }
        
        template<class Offset = fixed_dims_t<0>, class UShape = Shape>
        tensor_view<T, UShape, Shape> view() noexcept;

    private:
        T buffer_[shape().length()];
    };

    template<class T, class Shape, class Strides>
    class tensor_view {
    public:
        static constexpr auto shape() noexcept { return Shape{}; }
        static constexpr auto strides() noexcept { return Strides{}; }

        template<class UShape>
        tensor_view(tensor<T, UShape> &t, size_t offset) noexcept
            :buffer_(t.buffer().subspan(offset))
        {
        }

        auto buffer() noexcept { return buffer_; }

    private:
        std::span<T, Strides::length()> buffer_;
    };
    
    template<class T, class Shape>
    template<class Offset, class UShape>
    tensor_view<T, UShape, Shape> tensor<T, Shape>::view() noexcept {
        return { *this, Offset::length() };
    }

    // tensors
    template<class T, class Shape, class StridesA, class StridesB>
    void tensor_copy(tensor_view<T, Shape, StridesA> src, tensor_view<T, Shape, StridesB> dest) noexcept {
        auto src_buffer = src.buffer();
        std::copy(src_buffer.begin(), src_buffer.end(), dest.buffer().begin());
    }

    // math ops
    namespace mathops {
        struct acosh {
            float operator()(float v) const noexcept { return g_cpu_mt->acoshf(v); }
        };
    }

    template<class Op, class TVA, class TVB>
    void unary(TVA input, TVB output) {
        Op op;
        for (size_t i = 0; i < input.strides().length(); i++) {
            output.buffer()[i] = op(input.buffer()[i]);
        }
    }
}
