@using System.Linq
@using NetFabric.Hyperlinq
@using Nncase
@model Nncase.CodeGen.CPU.KernelMainModel
@{
  var inputCount = Model.PrimFunction.Parameters.Length;
}

#include <nncase/ntt/cpu_runtime.h>
#include "topo_aware_runtime.h"
#include "../device.h"
@foreach(var (s,i) in Model.Options.MemoryCapacities.Select((s,i) => (s,i)).Skip(1).SkipLast(1)){
@:uint8_t L@(i)Data[@(s)];
}
#include "kernel.h"

extern "C" void kernel_entry(nncase_runtime_cpu_mt_t *cpu_mt, uint8_t **inputs, uint8_t *rdata) {
  g_cpu_mt = cpu_mt;
  /* prepare inputs */
  @{
    var names = new List<string>();
  }
  @foreach(var (b,i) in Model.PrimFunction.Parameters.ToArray().OfType<Nncase.TIR.Buffer>().Select((b,i)=>(Model.GetInfo(b),i)))
  {
    names.Add(b.Name);
  @:std::span<@Html.Raw(b.ElemType), @b.Size> p@(b.Name)((@Html.Raw(b.ElemType) *)inputs[@i], @b.Size);
  @:tensor_view<@Html.Raw(b.ElemType), @Html.Raw(b.Dimensions), @Html.Raw(b.Strides)> @(b.Name)(p@(b.Name));
  @:
  }
  /* prepare rdatas */
  @foreach(var (b,i) in Model.RDataBuffers.OfType<Nncase.TIR.Buffer>().Select((b,i)=>(Model.GetInfo(b),i)))
  {
    names.Add(b.Name);
  @:std::span<@Html.Raw(b.ElemType), @b.Size> p@(b.Name)((@Html.Raw(b.ElemType) *)(rdata + @b.Offset), @b.Size);
  @:tensor_view<@Html.Raw(b.ElemType), @Html.Raw(b.Dimensions), @Html.Raw(b.Strides)> @(b.Name)(p@(b.Name));
  @:
  }

  @if (Model.Options.Hierarchies.Length > 1) {
    throw new NotSupportedException($"not support multi form topology!");
  }
  @if (Model.Options.Hierarchies[0].Any(h => h != 1)) {
    var hierarchy = Model.Options.Hierarchies[0];
  
  @:/* prepare wrapped kernel */
  @:auto wrapped_kernel = [&](@(string.Join(", ", Model.Options.HierarchyNames.Select(c => "size_t cur_" + c + "id")))) {
    foreach (var c in Model.Options.HierarchyNames) {
    @:@(c)id = cur_@(c)id;
    }
    @:uint8_t *data = (uint8_t *)cpu_mt->local_alloc(@(Model.DataSize), @(Model.Alignment));
    @:@(Model.PrimFunction.Name)(@(string.Join(", ", names)), data);
    @:cpu_mt->local_free(data);
  @:};

  @:/* invoke kernels */
  int count = 0;
  @foreach(var index in hierarchy.Select(i => Enumerable.Range(0, i)).CartesianProduct().Select(arr => arr.ToArray()))
  {
  @:std::thread t@(count++)(wrapped_kernel, @(string.Join(",", index)));
  }
  for (int i = 0; i < count; i++) {
  @:t@(i).join();
  }
  } else {
  @:/* invoke kernel */
  @:uint8_t *data = (uint8_t *)cpu_mt->local_alloc(@(Model.DataSize), @(Model.Alignment));
  @:@(Model.PrimFunction.Name)(@(string.Join(", ", names)), data);
  @:cpu_mt->local_free(data);
  }
}

#ifdef NNCASE_STANDALONE
#include <memory>

static void *local_alloc(size_t bytes, size_t alignment) {
#ifdef WIN32
    return _aligned_malloc(bytes, alignment);
#else
    size_t mask = alignment - 1;
    size_t aligned_bytes = bytes + (-bytes & mask);
    return aligned_alloc(alignment, bytes);
#endif
}

static void local_free(void *ptr) {
#ifdef WIN32
    _aligned_free(ptr);
#else
    free(ptr);
#endif
}

static nncase_runtime_cpu_mt_t nncase_cpu_mt_ = {
    .acosf = acosf,
    .acoshf = acoshf,
    .asinf = asinf,
    .asinhf = asinhf,
    .copysignf = copysignf,
    .cosf = cosf,
    .coshf = coshf,
    .erff = erff,
    .expf = expf,
    .fmodf = fmodf,
    .logf = logf,
    .nearbyintf = nearbyintf,
    .powf = powf,
    .roundf = roundf,
    .sinf = sinf,
    .sinhf = sinhf,
    .sqrtf = sqrtf,
    .tanhf = tanhf,
    .sram_address = nullptr,
    .local_alloc = local_alloc,
    .local_free = local_free,
    .failfast = nullptr,

#ifndef WIN32
    .memcpy = memcpy,
    .memmove = memmove,
    .memset = memset,
#endif
};

int main([[maybe_unused]] int argc, [[maybe_unused]] char** argv) {
  uint8_t *inputs[@inputCount];
  size_t align = @(Model.Alignment);
  @foreach(var (b,i) in Model.PrimFunction.Parameters.ToArray().OfType<Nncase.TIR.Buffer>().Select((b,i)=>(Model.GetInfo(b),i)))
  {
  @:inputs[@i] = (uint8_t *)local_alloc(sizeof(@Html.Raw(b.ElemType)) * @b.Size, align);
  }

  uint8_t* rdata = (uint8_t *)local_alloc(@Model.RDataSize, align);

  kernel_entry(&nncase_cpu_mt_, inputs, rdata);
  for (size_t i = 0; i < @inputCount; i++) {
    local_free(inputs[i]);
  }
  local_free(rdata);
  return 0;
}
#endif
