@using System.Linq
@using NetFabric.Hyperlinq
@using Nncase
@model Nncase.CodeGen.CPU.KernelMainModel
@{
  var inputCount = Model.PrimFunction.Parameters.Length;
}

#include <nncase/ntt/cpu_runtime.h>
#include "../device.h"
@foreach(var (s,i) in Model.Options.MemoryCapacities.Select((s,i) => (s,i)).Skip(1).SkipLast(1)){
@:uint8_t L@(i)Data[@(s)];
}
#include "kernel.h"

extern "C" void kernel_entry(nncase_runtime_cpu_mt_t *cpu_mt, uint8_t **inputs, uint8_t *rdata, uint8_t *data) {
  g_cpu_mt = cpu_mt;
  /* prepare inputs */
  @{
    var names = new List<string>();
  }
  @foreach(var (b,i) in Model.PrimFunction.Parameters.ToArray().OfType<Nncase.TIR.Buffer>().Select((b,i)=>(Model.GetInfo(b),i)))
  {
    names.Add(b.Name);
  @:std::span<@Html.Raw(b.ElemType), @b.Size> p@(b.Name)((@Html.Raw(b.ElemType) *)inputs[@i], @b.Size);
  @:tensor_view<@Html.Raw(b.ElemType), @Html.Raw(b.Dimensions), @Html.Raw(b.Strides)> @(b.Name)(p@(b.Name));
  @:
  }
  /* prepare rdatas */
  @foreach(var (b,i) in Model.RDataBuffers.OfType<Nncase.TIR.Buffer>().Select((b,i)=>(Model.GetInfo(b),i)))
  {
    names.Add(b.Name);
  @:std::span<@Html.Raw(b.ElemType), @b.Size> p@(b.Name)((@Html.Raw(b.ElemType) *)(rdata + @b.Offset), @b.Size);
  @:tensor_view<@Html.Raw(b.ElemType), @Html.Raw(b.Dimensions), @Html.Raw(b.Strides)> @(b.Name)(p@(b.Name));
  @:
  }
  @(Model.PrimFunction.Name)(@(string.Join(", ", names)), data);
}

#ifdef NNCASE_STANDALONE
uint8_t *aligned_malloc(size_t size, size_t alignment, void *&data_ptr) {
    size_t total_size = size + alignment;
    data_ptr = malloc(total_size);
    if (data_ptr == nullptr) {
        printf("bad alloc\n");
        std::terminate();
    }
    void *offset_ptr = std::align(alignment, size, data_ptr, total_size);
    if (offset_ptr == nullptr) {
        printf("bad align\n");
        std::terminate();
    }
    return static_cast<uint8_t *>(offset_ptr);
}

int main([[maybe_unused]] int argc, [[maybe_unused]] char** argv) {
  void* ptrs[@(inputCount + 2)];
  uint8_t* inputs[@inputCount];
  size_t align = @(Model.Alignment);
  @foreach(var (b,i) in Model.PrimFunction.Parameters.ToArray().OfType<Nncase.TIR.Buffer>().Select((b,i)=>(Model.GetInfo(b),i)))
  {
  @:inputs[@i] = aligned_malloc(sizeof(@Html.Raw(b.ElemType)) * @b.Size, align, ptrs[@i]);
  }

  uint8_t* rdata = aligned_malloc(@Model.RDataSize, align, ptrs[@inputCount]);
  uint8_t* data = aligned_malloc(@Model.DataSize, align, ptrs[@(inputCount + 1)]);

  kernel_entry(nullptr, inputs, rdata, data);
  for (size_t i = 0; i < @(inputCount + 2); i++) {
    free(ptrs[i]);
  }
  return 0;
}
#endif